<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://ead3.archivists.org/schema/"
  elementFormDefault="qualified" targetNamespace="http://ead3.archivists.org/schema/"
  xmlns:xa="http://xerces.apache.org"
  xmlns:e3="http://ead3.archivists.org/schema/"
  xmlns:vr="http://www.w3.org/2007/XMLSchema-versioning" vr:minVersion="1.1">

  <!--
           Encoded Archival Description
       	Version: EAD3
       	Release: 1.1.1
       	Date: 2019-12-16

       	Hosted by the Library of Congress at http://www.loc.gov/ead/.

       	Developed by the Society of American Archivists'
       	Technical Subcommittee for Encoded Archival Description (TS-EAD)
       	and Schema Development Team, 2010-2015.

       	Adopted by SAA Council, July 2015.

       	Lead schema developer: Terry Catapano

       	EAD3 was possible because of the generous support of the
       	Society of American Archivists, the Gladys Krieble Delmas Foundation,
       	the National Endowment for the Humanities, the Nationaal Archief of the
       	Netherlands, the Beinecke Rare Book and Manuscript Library,
       	the Institute for Advanced Technology in the Humanities at the
       	University of Virginia, and OCLC Research.

       	EAD3 Deliverables

       	ead3.dtd	ead3_undeprecated.dtd
       	ead3.rng	ead3_undeprecated.rng
       	ead3.xsd	ead3_undeprecated.xsd
       	ead3.sch

       	Notes:
       	-EAD3 is available as DTD, Relax NG Schema, and W3C Schema.
       	-The EAD3 DTD does not support the <objectxmlwrap> element.
       	-In the EAD3 DTD, attributes with anyURI, token, and string
       	data types are converted to CDATA.
       	-Deprecated EAD 2002 elements are available in the undprecated
       	versions of EAD3.
       	-A Schematron schema (ead3.sch) is available to validate external code lists
       	not maintained within EAD, standard attribute value patterns,
       	attribute or element co-ocurrence not enforcable in the schema,
       	and some encoding practices recommended for future migration.
           -->

  <!--
           ***************************************************
           Changes in version 1.1.1:
           1. The foreign element is now available as a child of the ref element.
              See https://github.com/SAA-SDT/EAD3/issues/522

           2. Fixed a bug in the XSD schemas that resulted in empty-only c12 elements being valid.
              See https://github.com/SAA-SDT/EAD3/issues/523

           ***************************************************


           ***************************************************
           Changes in version 1.1:

           1. The @render attribute can now be used with the quote element.
              See https://github.com/SAA-SDT/EAD3/issues/485

           2. The objectxmlwrap element can now be validated properly in the XSD schemas.
              See https://github.com/SAA-SDT/EAD3/issues/499
              (bug fix)

           3. Manually fixed a bug that was causing the descgrp element not to validate correctly in the undeprecated DTD.
              See https://github.com/SAA-SDT/EAD3/issues/503
              (bug fix)

           4. The date element is now a valid child of the part element.
              See https://github.com/SAA-SDT/EAD3/issues/505

           5. rightsdeclaration, a new element, has been added to the control section.
              See https://github.com/SAA-SDT/EAD3/issues/506
              (new element)

           6. The @localtype attribute can now be used with the conventiondeclaration element.
              See https://github.com/SAA-SDT/EAD3/issues/507

           7. The datatype associated with the @containerid attribute has been relaxed to xsd:string (in EAD3 version 1.0, the datatype for this attribute was restricted to xsd:NMTOKEN).
              See https://github.com/SAA-SDT/EAD3/issues/512

           *****************************************************
           -->
  <!-- include "ead_revised_defs.rng" -->

  <!-- begin ICAR extra types -->

  <!-- M011: creato "date.specificaSecolo" -->
  <!-- abrogati M011 e M012 a causa della ristrutturazione della gestione
       delle date
  <xs:complexType name="date.specificaSecolo">
    <xs:complexContent>
      <xs:extension base="date">
        <xs:assert xa:message="[&#x0a;&#x0a;
M012: Il contenuto di &lt;date>, quando è figlio di &lt;unittitle> e quando il suo&#x0a;
      @localtype vale &quot;SpecificaSecolo&quot;, deve soddisfare una ben precisa lista&#x0a;
      chiusa di valori possibili
      &#x0a;&#x0a;]"
          test="text() = ('Inizio', 'Metà', 'Prima metà', 'Primo quarto',
                          'Seconda metà', 'Secondo quarto', 'Terzo quarto',
                          'Ultimo quarto', 'Fine')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->

  <!-- M016: creato "date.estremoRemotoRecente" -->
  <!-- abrogati M016 e M017 a causa della ristrutturazione della gestione
       delle date
  <xs:complexType name="date.estremoRemotoRecente">
    <xs:complexContent>
      <xs:extension base="date">
        <xs:assert xa:message="[&#x0a;&#x0a;
M017: &lt;date>, quando è figlio di &lt;unittitle> e quando il suo @localtype vale&#x0a;
      &quot;SpecificaSecolo&quot;, non deve avere @certainty oppure, se @certainty è&#x0a;
      presente, il suo valore deve soddisfare una precisa lista chiusa di&#x0a;
      valori possibili
      &#x0a;&#x0a;]"
          test="   not(@certainty)
                or (@certainty = ('DataAnteQuem', 'DataApprossimativa',
                                  'DataAttribuita', 'DataIncerta', 'DataPostQuem',
                                  'DataIncertaEAttribuita'))"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->

  <!-- M047: creato "date.dataTestuale" -->
  <!-- abrogati M047 e M048 a causa della ristrutturazione della gestione
       delle date
  <xs:complexType name="date.dataTestuale">
    <xs:complexContent>
      <xs:extension base="date">
      <xs:assert xa:message="[&#x0a;&#x0a;
M048: In &lt;date>, quando @localtype è pari a &quot;DataTestuale&quot;, è obbligatorio che&#x0a;
      sia presente @normal e che il suo valore sia una data nel formato&#x0a;
      AAAA-MM-GG, o AAAAMMGG, o AAAA-MM, o AAAAMM, o AAAA
      &#x0a;&#x0a;]"
        test="   matches(@normal, '^([0-9]{4}((0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[0-1])??)??)$')
              or matches(@normal, '^([0-9]{4}(-(0[1-9]|1[0-2])(-(0[1-9]|[12][0-9]|3[0-1]))??)??)$')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->

  <!-- M010: creato "m.mixed.basic.plus.access.unittitle" -->
  <!-- annullato M010 per ristrutturazione della gestione
       delle date 
  <xs:complexType name="m.mixed.basic.plus.access.unittitle" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="m.mixed.basic.elements"/>
      <xs:group ref="m.access"/>
      <xs:element name="date" type="date">
  -->    
        <!-- annullati M011 e M012 per ristrutturazione della gestione
             delle date 
        <xs:alternative test="@localtype = 'SpecificaSecolo'" type="date.specificaSecolo"/>
        -->
        <!-- annullati M016 e M017 per ristrutturazione della gestione
             delle date 
        <xs:alternative test="   (@localtype = 'EstremoRemoto')
                              or (@localtype = 'EstremoRecente')" type="date.estremoRemotoRecente"/>
        -->
        <!-- annullati M047 e M048 per ristrutturazione della gestione
             delle date 
        <xs:alternative test="@localtype = 'DataTestuale'" type="date.dataTestuale"/>
        -->
    <!--
      </xs:element>
      <xs:element name="footnote" type="footnote"/>
      <xs:element name="num" type="num"/>
      <xs:element name="quote" type="quote"/>
    </xs:choice>
    -->
    <!-- annullato M013 per ristrutturazione della gestione delle date
    <xs:assert xa:message="[&#x0a;&#x0a;
M013: È obbligatorio, in &lt;unittitle>, che ogni eventuale figlio &lt;date> con&#x0a;
      @localtype pari a &quot;SpecificaSecolo&quot; sia preceduto da un altro &lt;date> con&#x0a;
      @localtype pari a &quot;EstremoRemotoSecolo&quot; o pari a&#x0a;
      &quot;EstremoRecenteSecolo&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="every $date in date[@localtype = 'SpecificaSecolo']
              satisfies (   $date/preceding-sibling::date[@localtype = 'EstremoRemotoSecolo']
                         or $date/preceding-sibling::date[@localtype = 'EstremoRecenteSecolo'])"/>
    -->
    <!-- annullato M018 per ristrutturazione della gestione delle date
    <xs:assert xa:message="[&#x0a;&#x0a;
M018: È obbligatorio, in &lt;unittitle>, che ad ogni eventuale figlio &lt;date>, con&#x0a;
      @localtype pari a &quot;EstremoRemoto&quot; oppure pari a &quot;EstremoRemotoSecolo&quot;,&#x0a;
      corrisponda un ulteriore eventuale figlio &lt;date>, con @localtype pari a&#x0a;
      &quot;EstremoRecente&quot; oppure pari a &quot;EstremoRecenteSecolo&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="  count(date[@localtype = ('EstremoRemoto', 'EstremoRemotoSecolo')])
              = count(date[@localtype = ('EstremoRecente', 'EstremoRecenteSecolo')])"/>
    -->
  <!--
  </xs:complexType>
  -->

  <!-- M239: creato il tipo "subject.tema", specializzazione di "subject",
             quando usato con @localtype pari a "Tematismo" -->
  <xs:complexType name="subject.tema">
    <xs:complexContent>
      <xs:extension base="subject">
        <xs:assert xa:message="[&#x0a;&#x0a;
M240: È obbligatoria in &lt;subject>, quando rappresenta un tematismo, la presenza&#x0a;
      di un (e un solo) figlio &lt;part> con @localtype pari a &quot;StatusScheda&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(part[@localtype = 'StatusScheda'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M241: È obbligatorio in &lt;subject>, quando rappresenta un tematismo, che&#x0a;
      il contenuto di un eventiale figlio &lt;part>, con @localtype pari&#x0a;
      a &quot;StatusScheda&quot;, soddisfi una ben precisa lista chiusa&#x0a;
      di valori possibili ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in part[@localtype = 'StatusScheda']
                satisfies $part/text() = ('Bozza', 'In validazione di primo livello',
                                          'Validata (primo livello)',
                                          'In validazione di secondo livello',
                                          'Validata (secondo livello)', 'Pubblicata',
                                          'Copia parallela')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M242: È obbligatoria in &lt;subject>, quando rappresenta un tematismo, la presenza&#x0a;
      di un (e un solo) figlio &lt;part> con @localtype pari a &quot;Denominazione&quot; 
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(part[@localtype = 'Denominazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M243: In &lt;subject>, quando rappresenta un tematismo, può essere presente&#x0a;
      al più un figlio &lt;part> con @localtype pari a &quot;Descrizione&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(part[@localtype = 'Descrizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M244: È obbligatoria in &lt;subject>, quando rappresenta un tematismo, che&#x0a;
      il contenuto dell'eventuale attributo @lang soddisfi lo standard&#x0a;
      ISO 693-3 e quindi, in particolare, corrisponda a esattamente&#x0a;
      tre lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@lang) or matches(@lang, '^[a-z]{3}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M245: In &lt;subject>, quando rappresenta un tematismo, può essere presente&#x0a;
      al più un figlio &lt;part> con @localtype pari&#x0a;
      a &quot;PercorsoRicercaSi&quot; oppure con @localtype pari&#x0a;
      a &quot;PercorsoRicercaNo&quot; e mai entrambi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(part[@localtype = ('PercorsoRicercaSi', 'PercorsoRicercaNo')])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M259: È obbligatoria in &lt;subject>, quando rappresenta un tematismo, che sia&#x0a;
      presente, e con valore non nullo, l'attributo @id
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="@id != ''"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M305: È obbligatorio in &lt;subject>, quando rappresenta un tematismo, che&#x0a;
      il contenuto di un eventiale figlio &lt;part>, con @localtype pari&#x0a;
      a &quot;Denominazione&quot;, soddisfi una ben precisa lista chiusa&#x0a;
      di valori possibili ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in part[@localtype = 'Denominazione']
                satisfies $part/text() = ('Antenati', 'Architettura', &quot;Archivi dell'Ebraismo&quot;,
                                          'Archivi per non dimenticare', 'Arti figurative',
                                          'Assistenza, beneficenza, previdenza', 'Chiesa cattolica',
                                          'Confessioni religiose', 'Donne',
                                          'Enti pubblici locali e territoriali', 'Imprese',
                                          'Inquisizione', 'Istruzione', 'Moda', 'Musica', 'Nobiltà',
                                          'Politica e sindacati', 'Psichiatria', 'Psicologia', 'Sanità',
                                          'Scienze naturali e matematiche', 'Scienze umane e sociali',
                                          'Spettacolo', 'Sport', 'Territorio (cartografia storica-catasti)',
                                          'Antifascismo e resistenza', 'Architetti',
                                          'Architettura/Urbanistica', 'Atti processuali', 'Azionismo',
                                          'Cancellerie', 'Carte da legare', 'Credito', 'Diplomatico',
                                          'Emilia-Romagna - Archivi femminili', 'Emilia-Romagna - ArchiviaMO',
                                          'Emilia-Romagna - Patrimonio archivistico di interesse ebraico',
                                          'Emilia-Romagna - Resistenza', 'Enti pubblici', 'Fonti audiovisive',
                                          'Fotografia', 'Giuristi', 'Grande guerra (1915-1918)', 'Letterati',
                                          'Libri liturgici e musicali', 'Marche - Imprese', 'Memoria',
                                          'Notarile', 'Rete Parri', 'Stampa periodica',
                                          'Strumenti di ricerca', 'Toscana - Archivi di personalità',
                                          &quot;Toscana - Archivi Pistoiesi del '900&quot;,
                                          'Toscana - Fondi librari', 'Toscana - Fuori dal manicomio',
                                          'Trentino Alto Adige - Archivi femminili', 'Tutela beni culturali',
                                          'Umbria - Archivi femminili', 'Umbria - Istruzione',
                                          'Umbria - Le carte in dimora', 'Umbria - Politica e sindacati',
                                          'Verdi')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M231: creato il tipo "archref.bibl", specializzazione di "archref"
             quando usato come figlio di "bibliography" (tranne quando
             @altrender e' pari a "LinkFonteArchivistica") -->
  <xs:complexType name="archref.bibl">
    <xs:complexContent>
      <xs:extension base="archref">
        <xs:assert xa:message="[&#x0a;&#x0a;
M232: È obbligatoria in &lt;archref>, quando contenuto in &lt;bibliography>, che&#x0a;
      sia presente l'attributo @id
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="@id"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M233: È obbligatoria in &lt;archref>, quando contenuto in &lt;bibliography>, la&#x0a;
      presenza di un (e un solo) title/part[@localtype = &quot;StatusScheda&quot;] 
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(title/part[@localtype = 'StatusScheda'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M234: È obbligatorio in &lt;archref>, quando contenuto in &lt;bibliography>, che il&#x0a;
      contenuto di title/part[@localtype = &quot;StatusScheda&quot;] soddisfi una ben&#x0a;
      precisa lista chiusa di valori possibili ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in title/part[@localtype = 'StatusScheda']
                satisfies $part/text() = ('Bozza', 'In validazione di primo livello',
                                          'Validata (primo livello)',
                                          'In validazione di secondo livello',
                                          'Validata (secondo livello)', 'Pubblicata',
                                          'Copia parallela')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M235: In &lt;archref>, quando contenuto in &lt;bibliography>, può essere presente,&#x0a;
      al più, un title/part[@localtype = &quot;TitoloBreve&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(title/part[@localtype = 'TitoloBreve'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M236: È obbligatoria in &lt;archref>, quando contenuto in &lt;bibliography>, la&#x0a;
      presenza di un (e un solo) title/part[@localtype = &quot;Titolo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(title/part[@localtype = 'Titolo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M237: In &lt;archref>, quando contenuto in &lt;bibliography>, può essere presente,&#x0a;
      al più, un title/part[@localtype = &quot;Descrizione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(title/part[@localtype = 'Descrizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M238: È obbligatoria in &lt;archref>, quando contenuto in &lt;bibliography>, che il&#x0a;
      contenuto dell'eventuale attributo @lang soddisfi lo standard ISO 693-3&#x0a;
      e quindi, in particolare, corrisponda a esattamente tre lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@lang) or matches(@lang, '^[a-z]{3}$')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M219: creato il tipo "processinfo.comp", generico per le compilazioni -->
  <xs:complexType name="processinfo.comp">
    <xs:complexContent>
      <xs:extension base="processinfo">
        <xs:assert xa:message="[&#x0a;&#x0a;
M220: In &lt;processifo>, quando relativo a una compilazione, deve essere,&#x0a;
      presente dentro un chronlist/chronitem/event, al più uno dei seguenti&#x0a;
      elementi contenti un &lt;part> con @localtype pari a &quot;Denominazione&quot;:&#x0a;
      (1) un &lt;persname> con @relator pari a &quot;Compilatore&quot;,&#x0a;
      oppure (2) un &lt;corpname> con @relator pari a &quot;Compilatore&quot;,&#x0a;
      oppure (3) un &lt;name> con @localtype pari a &quot;Software&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= (  count( chronlist/chronitem/event
                              /persname[@relator = 'Compilatore']
                              /part[@localtype = 'Denominazione'])
                      + count( chronlist/chronitem/event
                              /corpname[@relator = 'Compilatore']
                              /part[@localtype = 'Denominazione'])
                      + count( chronlist/chronitem/event
                              /name[@localtype = 'Software']
                              /part[@localtype = 'Denominazione']))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M221: In &lt;processifo>, quando relativo a una compilazione, deve essere&#x0a;
      presente, al più, un unico chronlist/chronitem/event/name/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(chronlist/chronitem/event/name/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M222: In &lt;processifo>, il contenuto di un eventuale&#x0a;
      chronlist/chronitem/event/name/part deve soddisfare una ben precisa lista&#x0a;
      chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in chronlist/chronitem/event/name/part
                satisfies $part/text() = ('Importazione', 'Integrazione successiva',
                                          'Prima redazione', 'Raccolta delle informazioni',
                                          'Revisione', 'Rielaborazione', 'Supervisione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M223: In &lt;processifo>, quando relativo a un tracciato, deve essere presente,&#x0a;
      al più, un unico chronlist/chronitem/datesingle
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(chronlist/chronitem/datesingle)"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M186: creato il tipo "bibliography.trac", generico per i tracciati -->
  <xs:complexType name="bibliography.trac">
    <xs:complexContent>
      <xs:extension base="bibliography">
        <xs:assert xa:message="[&#x0a;&#x0a;
M187: È obbligatoria in &lt;bibliography>, quando relativo a un tracciato, che sia&#x0a;
      presente un (e un solo) figlio &lt;bibref> con attributo @id e che il&#x0a;
      valore di tale attributo non sia nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="(1 = count(bibref/@id)) and not(bibref/@id = '')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M189: È obbligatoria in &lt;bibliography>, quando relativo a un tracciato,&#x0a;
      la presenza di un (e un solo)&#x0a;
      bibref/title/part[@localtype = &quot;StatusScheda&quot;] 
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/title/part[@localtype = 'StatusScheda'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M190: È obbligatoria in &lt;bibliography>, quando relativo a un tracciato, che&#x0a;
      il contenuto di bibref/title/part[@localtype = &quot;StatusScheda&quot;] soddisfi&#x0a;
      una ben precisa lista chiusa di valori possibili ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in bibref/title/part[@localtype = 'StatusScheda']
                satisfies $part/text() = ('Bozza', 'In validazione di primo livello',
                                          'Validata (primo livello)',
                                          'In validazione di secondo livello',
                                          'Validata (secondo livello)', 'Pubblicata',
                                          'Copia parallela')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M225: È obbligatorio in &lt;bibliography>, quando relativo a un tracciato, che&#x0a;
      il contenuto degli eventuali bibref/@lang soddisfi lo standard&#x0a;
      ISO 693-3 e quindi, in particolare, corrisponda a esattamente tre&#x0a;
      lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $lang in bibref/@lang
                satisfies matches($lang, '^[a-z]{3}$')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M186: creato il tipo "bibliography.fntn", specifico per i tracciati
             di fonte normativa -->
  <xs:complexType name="bibliography.fntn">
    <xs:complexContent>
      <xs:extension base="bibliography.trac">
        <xs:assert xa:message="[&#x0a;&#x0a;
M188: In &lt;bibliography>, quando @localtype è pari a &quot;FonteNormativa&quot;,&#x0a;
      può essere presente al più un unico&#x0a;
      bibref/num[@localtype = &quot;IdentificativoNIR&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/num[@localtype = 'IdentificativoNIR'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M191: In &lt;bibliography>, quando @localtype è pari a &quot;FonteNormativa&quot;, deve&#x0a;
      essere presente almeno un&#x0a;
      bibref/corpname[@relator = &quot;AutoritaEmittente&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="bibref/corpname[@relator = 'AutoritaEmittente']/part"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M192: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;FonteNormativa&quot;, la presenza di un (e un solo)&#x0a;
      bibref/genreform[@localtype = &quot;Tipologia&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/genreform[@localtype = 'Tipologia']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M193: È obbligatoria, in &lt;bibliography> quando @localtype è pari a&#x0a;
      &quot;FonteNormativa&quot;, la presenza di un (e un solo) bibref/date
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/date)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M194: In &lt;bibliography>, quando @localtype è pari a &quot;FonteNormativa&quot;, può&#x0a;
      essere presente al più un bibref/title/part[@localtype = &quot;TitoloAtto&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'TitoloAtto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M195: In &lt;bibliography>, quando @localtype è pari a &quot;FonteNormativa&quot;, può&#x0a;
      essere presente al più un bibref/title/part[@localtype = &quot;Annesso&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'Annesso'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M224: In &lt;bibliography>, quando @localtype è pari a &quot;FonteNormativa&quot;, può&#x0a;
      essere presente al più un bibref/title/part[@localtype = &quot;NumeroAtto&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'NumeroAtto'])"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M186: creato il tipo "bibliography.rifb", specifico per i tracciati
             di riferimento bibliografico -->
  <xs:complexType name="bibliography.rifb">
    <xs:complexContent>
      <xs:extension base="bibliography.trac">
        <xs:assert xa:message="[&#x0a;&#x0a;
M196: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/persname[@relator = &quot;Autore&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/persname[@relator = 'Autore']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M197: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/persname[@relator = &quot;Curatore&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/persname[@relator = 'Curatore']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M198: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/genreform[@localtype = &quot;Tipologia&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/genreform[@localtype = 'Tipologia']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M199: È obbligatoria in &lt;bibliography>, quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, che il contenuto di&#x0a;
      bibref/genreform[@localtype = &quot;Tipologia&quot;]/part soddisfi una ben precisa&#x0a;
      lista chiusa di valori possibili ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in bibref/genreform[@localtype = 'Tipologia']/part
                satisfies $part/text() = ('Atti', 'Catalogo mostra', 'Catalogo museo',
                                          'Contributo in miscellanea', 'Contributo in periodico',
                                          'Libro', 'Monografia', 'Fonte normativa',
                                          'NR (recupero pregresso)', 'Periodico',
                                          'Pubblicazione multimediale', 'Quotidiano', 'Rivista',
                                          'Studi', 'Tesi di laurea', 'Voce in opera enciclopedica',
                                          'Capitolo di libro', 'Intervento in convegno')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M200: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/title/part[@localtype = &quot;TitoloLibroOrRivista&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/title/part[@localtype = 'TitoloLibroOrRivista'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M201: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/title/part[@localtype = &quot;TitoloContributo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'TitoloContributo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M202: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/title/part[@localtype = &quot;TitoloCorrelato&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'TitoloCorrelato'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M203: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/title/part[@localtype = &quot;NotaTitoloCorrelato&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'NotaTitoloCorrelato'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M204: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/title/part[@localtype = &quot;SiglaCitazione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/title/part[@localtype = 'SiglaCitazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M205: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/geogname[@localtype = &quot;LuogoPubblicazione&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/geogname[@localtype = 'LuogoPubblicazione']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M206: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/date[@localtype = &quot;DataPubblicazione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/date[@localtype = 'DataPubblicazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M207: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/corpname[@localtype = &quot;Editore&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/corpname[@localtype = 'Editore']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M208: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/geogname[@localtype = &quot;LuogoEdizione&quot;]/part
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/geogname[@localtype = 'LuogoEdizione']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M209: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/date[@localtype = &quot;AnnoEdizione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/date[@localtype = 'AnnoEdizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M210: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un bibref/num[@localtype = &quot;NumEdizione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/num[@localtype = 'NumEdizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M211: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un bibref/title/part[@localtype = &quot;Volume&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'Volume'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M212: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;&#x0a;
      può essere presente al più un bibref/title/part[@localtype = &quot;Pagine&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'Pagine'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M213: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/subject/part[@localtype = &quot;Abstract&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/subject/part[@localtype = 'Abstract'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M214: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;,&#x0a;
      può essere presente al più un&#x0a;
      bibref/ref/date[@localtype = &quot;DataInserimento&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/ref/date[@localtype = 'DataInserimento'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M226: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;&#x0a;
      può essere presente al più un&#x0a;
      bibref/title/part[@localtype = &quot;Specifiche&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'Specifiche'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M227: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoBibliografico&quot;, la presenza di un (e un solo)&#x0a;
      bibref/ref[@linkrole = &quot;BidSBN&quot;]/@id
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/ref[@linkrole = 'BidSBN']/@id)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M228: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;&#x0a;
      può essere presente al più un bibref/ref[@linkrole = &quot;BidSBN&quot;]/@href
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/ref[@linkrole = 'BidSBN']/@href)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M229: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;&#x0a;
      può essere presente al più un&#x0a;
      bibref/ref/title/part[@localtype = &quot;Didascalia&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/ref/title/part[@localtype = 'Didascalia'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M230: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoBibliografico&quot;&#x0a;
      può essere presente al più un&#x0a;
      bibref/ref/title/part[@localtype = &quot;Qualifica&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/ref/title/part[@localtype = 'Qualifica'])"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M186: creato il tipo "bibliography.rifw", specifico per i tracciati
             di riferimento web -->
  <xs:complexType name="bibliography.rifw">
    <xs:complexContent>
      <xs:extension base="bibliography.trac">
        <xs:assert xa:message="[&#x0a;&#x0a;
M215: È obbligatoria, in &lt;bibliography> quando @localtype è pari&#x0a;
      a &quot;RiferimentoWeb&quot;, la presenza di un (e un solo)&#x0a;
      bibref/title/part[@localtype = &quot;Denominazione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(bibref/title/part[@localtype = 'Denominazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M216: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoWeb&quot;, può&#x0a;
      essere presente al più un bibref/title/part[@localtype = &quot;Descrizione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/title/part[@localtype = 'Descrizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M217: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoWeb&quot;, può&#x0a;
      essere presente al più un bibref/date[@localtype = &quot;DataInserimento&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/date[@localtype = 'DataInserimento'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M218: In &lt;bibliography>, quando @localtype è pari a &quot;RiferimentoWeb&quot;, può&#x0a;
      essere presente al più un bibref/ref/@href
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibref/ref/@href)"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M185: creato il tipo "archdesc.base" -->
  <xs:complexType name="archdesc.base">
    <xs:sequence>
      <xs:element name="did" type="did"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="m.desc.base"/>
        <xs:element name="dsc" type="dsc"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="relatedencoding" type="xs:token"/>
    <xs:attributeGroup ref="am.desc.base"/>
    <xs:attributeGroup ref="a.level"/>
    <xs:attribute name="base" type="xs:anyURI"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M049: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/langmaterial[@localtype = &quot;LinguaDescrizione&quot;]/language/@lang
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(did/langmaterial[@localtype = 'LinguaDescrizione']/language/@lang)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M159: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;odd> con @localtype&#x0a;
      pari ad &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(odd[@localtype = 'Osservazioni'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M295: È obbligatorio in &lt;archdesc> che il contenuto degli eventuali&#x0a;
      did/langmaterial[@localtype = &quot;LinguaDescrizione&quot;]/language/@lang&#x0a;
      soddisfino lo standard ISO 693-3 e quindi, in particolare, corrisponda&#x0a;
      a esattamente tre lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $lang in did/langmaterial[@localtype = 'LinguaDescrizione']/language/@lang
                satisfies matches($lang, '^[a-z]{3}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M302: In &lt;archdesc> può essere presente, al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkFonteNormativa&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkFonteNormativa'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M303: In &lt;archdesc> può essere presente, al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoWeb&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoWeb'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M314: In &lt;archdesc> può essere presente al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoBibliografico&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoBibliografico'])"/>
  </xs:complexType>

  <!-- M185: creato il tipo "archdesc.strc", derivato per estensione da
             "archdesc.base" e utilizzato per gli strumenti di ricerca -->
  <xs:complexType name="archdesc.strc">
    <xs:complexContent>
      <xs:extension base="archdesc.base">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- M185: creato il tipo "archdesc.comp", derivato per estensione da
             "archdesc.base" e utilizzato per i complessi archivistici -->
  <xs:complexType name="archdesc.comp">
    <xs:complexContent>
      <xs:extension base="archdesc.base">
        <xs:assert xa:message="[&#x0a;&#x0a;
M008: È obbligatoria, in &lt;archdesc>, la presenza di @level
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="@level"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M003: È obbligatorio che in &lt;archdesc> sia presente almeno un did/unitid
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="did/unitid"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M006: È obbligatorio che in &lt;archdesc> sia presente uno, e un solo,&#x0a;
      &lt;processinfo> con @localtype pari a &quot;StatusScheda&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(processinfo[@localtype = 'StatusScheda'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M007: È obbligatorio che, in &lt;archdesc>, il &lt;processinfo> con @localtype pari a&#x0a;
      &quot;StatusScheda&quot; abbia almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="processinfo[@localtype = 'StatusScheda']/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M009: È obbligatoria, in &lt;archdesc>, la presenza di uno e un solo&#x0a;
      did/unittitle[@localtype = &quot;Denominazione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(did/unittitle[@localtype = 'Denominazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M022: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;custodhist>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(custodhist)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M023: In &lt;archdesc>, l'eventuale figlio &lt;custodhist> deve avere almeno un&#x0a;
      figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (custodhist) then custodhist/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M024: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;appraisal> con&#x0a;
      @localtype pari a &quot;ProcedureScarto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(appraisal[@localtype = 'ProcedureScarto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M025: In &lt;archdesc> l'eventuale figlio &lt;appraisal>, con @localtype pari a&#x0a;
      &quot;ProcedureScarto&quot;, deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (appraisal[@localtype = 'ProcedureScarto'])
                then appraisal[@localtype = 'ProcedureScarto']/p
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M026: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;accruals>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(accruals)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M027: In &lt;archdesc> l'eventuale figlio &lt;accruals> deve avere almeno un figlio&#x0a;
      &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (accruals) then accruals/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M028: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;acqinfo>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(acqinfo)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M029: In &lt;archdesc> l'eventuale figlio &lt;acqinfo> deve avere almeno un figlio&#x0a;
      &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (acqinfo) then acqinfo/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M030: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;odd> con @localtype&#x0a;
      pari ad &quot;AltreInfo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(odd[@localtype = 'AltreInfo'])"/>
        <!--
        <xs:assert xa:message="[&#x0a;&#x0a;
M159: In &lt;archdesc> è ammesso, al più, un unico figlio &lt;odd> con @localtype&#x0a;
      pari ad &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(odd[@localtype = 'Osservazioni'])"/>
          -->
        <!--          
        <xs:assert xa:message="[&#x0a;&#x0a;
M031: In &lt;archdesc> gli eventuali figli &lt;odd> devono avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $odd in odd satisfies $odd/p"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M160: In &lt;archdesc> gli eventuali figli &lt;odd> devono avere @localtype che vale&#x0a;
      &quot;AltreInfo&quot; od &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $odd in odd
                satisfies $odd/@localtype = ('AltreInfo', 'Osservazioni')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M033: In &lt;archdesc> non è ammesso un figlio &lt;accessrestrict> diretto con&#x0a;
      @localtype pari a &quot;NoteCondizioniAccesso&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(accessrestrict[@localtype = 'NoteCondizioniAccesso'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M034: &lt;archdesc> non è ammesso più di un&#x0a;
       accessrestrict[@localtype = &quot;CondizioniAccesso&quot;]&#x0a;
      /accessrestrict[@localtype = &quot;NoteCondizioniAccesso&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( accessrestrict[@localtype = 'CondizioniAccesso']
                           /accessrestrict[@localtype = 'NoteCondizioniAccesso'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M035: In &lt;archdesc> non è ammesso un figlio &lt;userestrict> diretto con&#x0a;
      @localtype pari a &quot;NoteCondizioniUtilizzo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(userestrict[@localtype = 'NoteCondizioniUtilizzo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M036: &lt;archdesc> non ammette più di discendente (e comunque non figlio diretto)&#x0a;
      &lt;userestrict> con @localtype pari a &quot;NoteCondizioniUtilizzo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(userestrict//userestrict[@localtype = 'NoteCondizioniUtilizzo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M040: In &lt;archdesc> deve essere presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@unit = &quot;MetriLineari&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@unit = 'MetriLineari'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M041: In &lt;archdesc> deve essere presente, al più, un unico&#x0a;
      did/physdesc[@localtype = &quot;ConsistenzaTotale&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdesc[@localtype = 'ConsistenzaTotale'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M042: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/physdescstructured/descriptivenote
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/descriptivenote)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M043: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;StatoDiConservazione&quot;])
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/didnote[@localtype = 'StatoDiConservazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M044: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;CondizioniDelMateriale&quot;])
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/didnote[@localtype = 'CondizioniDelMateriale'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M045: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;RestauroOAltriInterventi&quot;])
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/didnote[@localtype = 'RestauroOAltriInterventi'])"/>
        <!-- spostato in archdesc.base
        <xs:assert xa:message="[&#x0a;&#x0a;
M049: In &lt;archdesc> non deve essere presente più di un&#x0a;
      did/langmaterial/language/@lang
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/langmaterial/language/@lang)"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M067: In &lt;archdesc> non deve essere presente più di un &lt;accessrestrict>&#x0a;
      con @localtype pari a &quot;CondizioniAccesso&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(accessrestrict[@localtype = 'CondizioniAccesso'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M068: In &lt;archdesc> l'eventuale figlio &lt;accessrestrict>, con @localtype pari&#x0a;
      a &quot;CondizioniAccesso&quot; deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $acc in accessrestrict[@localtype = 'CondizioniAccesso']
                satisfies $acc/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M076: In &lt;archdesc>, se sono presenti degli&#x0a;
      accessrestrict[@localtype = &quot;CondizioniAccesso&quot;]/p, allora i contenuti dei&#x0a;
      &lt;p> devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $p in accessrestrict[@localtype = 'CondizioniAccesso']/p
                satisfies $p/text() = ('Liberamente accessibile', 'Parzialmente accessibile',
                                       'Non accessibile', 'Accessibile previa autorizzazione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M077: In &lt;archdesc>, se sono presenti dei userestrict/p, allora i contenuti&#x0a;
      dei &lt;p> devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $p in userestrict/p
                satisfies $p/text() = ('Riproduzione libera', 'Riproduzione negata',
                                       'Riproduzione a  pagamento', 'Riproduzione a fini di studio e ricerca',
                                       'Riproduzione sottoposta ad autorizzazione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M078: In &lt;archdesc>, se sono presenti dei&#x0a;
      did/didnote[@localtype = &quot;StatoDiConservazione&quot;], allora i contenuti&#x0a;
      dei &lt;didnote> devono soddisfare una precisa lista chiusa di valori&#x0a;
      ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $note in did/didnote[@localtype = 'StatoDiConservazione']
                satisfies $note/text() = ('Pessimo', 'Mediocre', 'Discreto', 'Buono', 'Ottimo')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M161: In &lt;archdesc> non deve essere presente più di un &lt;arrangement> con&#x0a;
      @localtype pari a &quot;CriteriOrdinamento&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(arrangement[@localtype = 'CriteriOrdinamento'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M178: In &lt;archdesc>, è ammesso, al più, un unico figlio &lt;scopecontent> con&#x0a;
      @localtype pari a &quot;AmbitiEContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'AmbitiEContenuto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M179: In &lt;archdesc>, l'eventuale figlio &lt;scopecontent>, con @localtype pari a&#x0a;
      &quot;AmbitiEContenuto&quot;, deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent[@localtype = 'AmbitiEContenuto']
                satisfies $s/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M180: In &lt;archdesc>, gli eventuali figli &lt;scopecontent> devono avere @localtype&#x0a;
      pari a &quot;AmbitiEContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent
                satisfies $s/@localtype = 'AmbitiEContenuto'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M304: In &lt;archdesc>, quando rappresenta un complesso archivistico, gli&#x0a;
      eventuali valori di&#x0a;
       relations/relation[@relationtype = &quot;cpfrelation&quot;]&#x0a;
      /relationentry/@localtype&#x0a;
      devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $type in ( relations/relation[@relationtype = 'cpfrelation']
                                /relationentry/@localtype)
                satisfies $type = ('Soggetto conservatore', 'Soggetto vigilante', 'Proprietario',
                                   'Possessore', 'Detentore di diritti', 'Soggetto produttore')"/>
        <xs:assert test="1 >= count(e3:userestrict)"/> <!-- ??? -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M185: creato il tipo "archdesc.prog", derivato per estensione da
             "archdesc.base" e utilizzato, genericamente, per i tracciati
             dei progetti -->
  <xs:complexType name="archdesc.prog">
    <xs:complexContent>
      <xs:extension base="archdesc.base">
        <!-- soppresso poiche' doppione di M049
        <xs:assert xa:message="[&#x0a;&#x0a;
M294: In &lt;archdesc>, quando rappresenta un progetto, può essere presente,&#x0a;
      al più, un unico did/langmaterial/language
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/langmaterial/language)"/>
          -->
          <!-- spostato in "archdesc.base"
        <xs:assert xa:message="[&#x0a;&#x0a;
M295: È obbligatorio in &lt;archdesc>, quando relativo a un progetto, che il&#x0a;
      contenuto degli eventuali did/langmaterial/language/@lang soddisfino lo&#x0a;
      standard ISO 693-3 e quindi, in particolare, corrisponda a esattamente&#x0a;
      tre lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $lang in did/langmaterial/language/@lang
                satisfies matches($lang, '^[a-z]{3}$')"/>
                -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M296: È obbligatoria in &lt;archdesc>, quando relativo a un progetto, la presenza&#x0a;
      di un (e un solo)&#x0a;
      accessrestrict/accessrestrict[@localtype = &quot;VisibilitaFE&quot;]/p
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(accessrestrict/accessrestrict[@localtype = 'VisibilitaFE']/p)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M297: In &lt;archdesc>, quando relativo a un progetto, il valore di&#x0a;
      accessrestrict/accessrestrict[@localtype = &quot;VisibilitaFE&quot;]/p&#x0a;
      deve soddisfare il contenuto di una precisa lista chiusa di valori&#x0a;
      ammessi
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $p in accessrestrict/accessrestrict[@localtype = 'VisibilitaFE']/p
                satisfies $p/text() = ('Completa', 'Non visibile',
                                       'Descrizione Libera e Risorsa Protetta (login)',
                                       'Descrizione Protetta e Risorsa Protetta (login)',
                                       'Descrizione Libera e Risorse Riservata (autorizzazione)',
                                       'Descrizione Riservata e Risorse Riservata (autorizzazione)')"/>
        <!-- spostato in archdesc.base e in c.base
        <xs:assert xa:message="[&#x0a;&#x0a;
M302: In &lt;archdesc>, quando rappresenta un progetto, può essere presente,&#x0a;
      al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkFonteNormativa&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkFonteNormativa'])"/>
          -->
        <!-- spostato in archdesc.base e in c.base
        <xs:assert xa:message="[&#x0a;&#x0a;
M303: In &lt;archdesc>, quando rappresenta un progetto, può essere presente,&#x0a;
      al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoWeb&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoWeb'])"/>
          -->
        <!-- spostato in archdesc.base e in c.base
        <xs:assert xa:message="[&#x0a;&#x0a;
M314: In &lt;archdesc>, quando rappresenta un progetto, può essere presente,&#x0a;
      al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoBibliografico&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoBibliografico'])"/>
          -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M185: creato il tipo "archdesc.prdg", derivato per estensione da
             "archdesc.prog" e utilizzato, specificamente, per i tracciati
             che corrispondono a un progetto di digitalizzazione -->
  <xs:complexType name="archdesc.prdg">
    <xs:complexContent>
      <xs:extension base="archdesc.prog">
        <xs:assert xa:message="[&#x0a;&#x0a;
M246: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;phystech> con @localtype&#x0a;
      pari ad &quot;ArchitetturaSistema&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(phystech[@localtype = 'ArchitetturaSistema'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M247: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico did/physdescstructured/dimensions dove&#x0a;
      il @physdescstructuredtype di &lt;physdescstructured> è pari&#x0a;
      a &quot;spaceoccupied&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured[@physdescstructuredtype = 'spaceoccupied']/dimensions)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M248: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;FormatoImmaginiOnline&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'FormatoImmaginiOnline'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M249: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;FormatoRiproduzione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'FormatoRiproduzione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M250: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;Risoluzione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'Risoluzione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M251: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;GestioneColore&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'GestioneColore'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M252: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;phystech> con @localtype&#x0a;
      pari ad &quot;AltroSoftware&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(phystech[@localtype = 'AltroSoftware'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M253: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;phystech> con @localtype&#x0a;
      pari a &quot;StrumentazioneRipresa&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(phystech[@localtype = 'StrumentazioneRipresa'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M254: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;phystech> con @localtype&#x0a;
      pari a &quot;StandardAdottati&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(phystech[@localtype = 'StandardAdottati'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M255: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;scopecontent> con @localtype&#x0a;
      pari a &quot;NoteProgetto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'NoteProgetto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M256: In &lt;archdesc>, quando rappresenta un progetto di digitalizzazione, può&#x0a;
      essere presente, al più, un unico figlio &lt;processinfo>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(processinfo)"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M001: creato il tipo "c.base" -->
  <xs:complexType name="c.base">
    <xs:sequence>
      <xs:element name="did" type="did"/>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.desc.base"/>
      <xs:element name="c" minOccurs="0" maxOccurs="unbounded">
        <xs:alternative type="c.arch" test="@level = 'file'"/>
        <xs:alternative type="c.docu" test="@level = 'item'"/>
        <xs:alternative type="c.comp"/>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="am.desc.c"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M003: È obbligatorio che in &lt;c> sia presente almeno un did/unitid
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="did/unitid"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M006: È obbligatorio che in &lt;c> sia presente uno, e un solo, &lt;processinfo> con&#x0a;
      @localtype pari a &quot;StatusScheda&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 = count(processinfo[@localtype = 'StatusScheda'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M007: È obbligatorio che, in &lt;c>, il &lt;processinfo> con @localtype pari a&#x0a;
      &quot;StatusScheda&quot; abbia almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="processinfo[@localtype = 'StatusScheda']/p"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M033: In &lt;c> non è ammesso un figlio &lt;accessrestrict> diretto con @localtype&#x0a;
      pari a &quot;NoteCondizioniAccesso&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="not(accessrestrict[@localtype = 'NoteCondizioniAccesso'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M034: &lt;c> non è ammesso più di un&#x0a;
       accessrestrict[@localtype = &quot;CondizioniAccesso&quot;]&#x0a;
      /accessrestrict[@localtype = &quot;NoteCondizioniAccesso&quot;]
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count( accessrestrict[@localtype = 'CondizioniAccesso']
                         /accessrestrict[@localtype = 'NoteCondizioniAccesso'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M035: In &lt;c> non è ammesso un figlio &lt;userestrict> diretto con @localtype pari&#x0a;
      a &quot;NoteCondizioniUtilizzo&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="not(userestrict[@localtype = 'NoteCondizioniUtilizzo'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M036: &lt;c> non ammette più di discendente (e comunque non figlio diretto)&#x0a;
      &lt;userestrict> con @localtype pari a &quot;NoteCondizioniUtilizzo&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(userestrict//userestrict[@localtype = 'NoteCondizioniUtilizzo'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M042: In &lt;c> non deve essere presente più di un&#x0a;
      did/physdescstructured/descriptivenote
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(did/physdescstructured/descriptivenote)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M043: In &lt;c> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;StatoDiConservazione&quot;])
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(did/didnote[@localtype = 'StatoDiConservazione'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M044: In &lt;c> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;CondizioniDelMateriale&quot;])
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(did/didnote[@localtype = 'CondizioniDelMateriale'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M045: In &lt;c> non deve essere presente più di un&#x0a;
      did/didnote[@localtype = &quot;RestauroOAltriInterventi&quot;])
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(did/didnote[@localtype = 'RestauroOAltriInterventi'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M049: In &lt;c> deve essere presente, al più, un unico&#x0a;
      did/langmaterial[@localtype = &quot;LinguaDescrizione&quot;]/language/@lang
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/langmaterial[@localtype = 'LinguaDescrizione']/language/@lang)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M067: In &lt;c> non deve essere presente più di un &lt;accessrestrict> con&#x0a;
      @localtype pari a &quot;CondizioniAccesso&quot;
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="1 >= count(accessrestrict[@localtype = 'CondizioniAccesso'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M068: In &lt;c> l'eventuale figlio &lt;accessrestrict>, con @localtype pari&#x0a;
      a &quot;CondizioniAccesso&quot; deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="every $acc in accessrestrict[@localtype = 'CondizioniAccesso']
              satisfies $acc/p"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M076: In &lt;c>, se sono presenti degli&#x0a;
      accessrestrict[@localtype = &quot;CondizioniAccesso&quot;]/p, allora i contenuti dei&#x0a;
      &lt;p> devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="every $p in accessrestrict[@localtype = 'CondizioniAccesso']/p
              satisfies $p/text() = ('Liberamente accessibile', 'Parzialmente accessibile',
                                     'Non accessibile', 'Accessibile previa autorizzazione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M077: In &lt;c>, se sono presenti dei userestrict/p, allora i contenuti dei &lt;p>&#x0a;
      devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $p in userestrict/p
                satisfies $p/text() = ('Riproduzione libera', 'Riproduzione negata',
                                       'Riproduzione a  pagamento', 'Riproduzione a fini di studio e ricerca',
                                       'Riproduzione sottoposta ad autorizzazione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M078: In &lt;c>, se sono presenti dei&#x0a;
      did/didnote[@localtype = &quot;StatoDiConservazione&quot;], allora i contenuti&#x0a;
      dei &lt;didnote> devono soddisfare una precisa lista chiusa di valori&#x0a;
      ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $note in did/didnote[@localtype = 'StatoDiConservazione']
                satisfies $note/text() = ('Pessimo', 'Mediocre', 'Discreto', 'Buono', 'Ottimo')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M161: In &lt;c> non deve essere presente più di un &lt;arrangement> con @localtype&#x0a;
      pari a &quot;CriteriOrdinamento&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(arrangement[@localtype = 'CriteriOrdinamento'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M159: In &lt;c> è ammesso, al più, un unico figlio &lt;odd> con @localtype pari&#x0a;
      ad &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(odd[@localtype = 'Osservazioni'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M295: È obbligatorio in &lt;c> che il contenuto degli eventuali&#x0a;
      did/langmaterial/language[@localtype = &quot;LinguaDescrizione&quot;]/@lang&#x0a;
      soddisfino lo standard ISO 693-3 e quindi, in particolare, corrisponda&#x0a;
      a esattamente tre lettere minuscole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $lang in did/langmaterial[@localtype = 'LinguaDescrizione']/language/@lang
                satisfies matches($lang, '^[a-z]{3}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M302: In &lt;c> può essere presente, al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkFonteNormativa&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkFonteNormativa'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M303: In &lt;c> può essere presente, al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoWeb&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoWeb'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M314: In &lt;c> può essere presente al più, un unico&#x0a;
      bibliography/bibliography[@localtype = &quot;LinkRiferimentoBibliografico&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(bibliography/bibliography[@localtype = 'LinkRiferimentoBibliografico'])"/>
  </xs:complexType>

  <!-- M001: creato il tipo "c.comp" -->
  <xs:complexType name="c.comp">
    <xs:complexContent>
      <xs:extension base="c.base">
        <xs:assert xa:message="[&#x0a;&#x0a;
M008: È obbligatoria, in &lt;c>, la presenza di @level
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="@level"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M009: È obbligatoria, in &lt;c>, quando rappresenta un complesso archivistico, la&#x0a;
      presenza di uno e un solo did/unittitle[@localtype = &quot;Denominazione&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(did/unittitle[@localtype = 'Denominazione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M022: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;custodhist>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(custodhist)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M023: In &lt;c>, quando rappresenta un complesso archivistico, l'eventuale figlio&#x0a;
      &lt;custodhist> deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (custodhist) then custodhist/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M024: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;appraisal> con @localtype pari a &quot;ProcedureScarto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(appraisal[@localtype = 'ProcedureScarto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M025: In &lt;c>, quando rappresenta un complesso archivistico, l'eventuale figlio&#x0a;
      &lt;appraisal>, con @localtype pari a &quot;ProcedureScarto&quot;, deve avere almeno&#x0a;
      un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (appraisal[@localtype = 'ProcedureScarto'])
                then appraisal[@localtype = 'ProcedureScarto']/p
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M026: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;accruals>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(accruals)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M027: In &lt;c>, quando rappresenta un complesso archivistico, l'eventuale figlio&#x0a;
      &lt;accruals> deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (accruals) then accruals/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M028: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;acqinfo>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(acqinfo)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M029: In &lt;c>, quando rappresenta un complesso archivistico, l'eventuale figlio&#x0a;
      &lt;acqinfo> deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (acqinfo) then acqinfo/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M030: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;odd> con @localtype pari ad &quot;AltreInfo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(odd[@localtype = 'AltreInfo'])"/>
        <!--
        <xs:assert xa:message="[&#x0a;&#x0a;
M159: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;odd> con @localtype pari a &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(odd[@localtype = 'Osservazioni'])"/>
          -->
        <!--
        <xs:assert xa:message="[&#x0a;&#x0a;
M031: In &lt;c>, quando rappresenta un complesso archivistico, gli eventuali figli&#x0a;
      &lt;odd> devono avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $odd in odd satisfies $odd/p"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M160: In &lt;c>, quando rappresenta un complesso archivistico, gli eventuali figli&#x0a;
      &lt;odd> devono avere @localtype che vale &quot;AltreInfo&quot; od &quot;Osservazioni&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $odd in odd
                satisfies $odd/@localtype = ('AltreInfo', 'Osservazioni')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M040: In &lt;c>, quando rappresenta un complesso archivistico, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@unit = &quot;MetriLineari&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@unit = 'MetriLineari'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M041: In &lt;c>, quando rappresenta un complesso archivistico, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdesc[@localtype = &quot;ConsistenzaTotale&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdesc[@localtype = 'ConsistenzaTotale'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M046: In &lt;c>, quando rappresenta un complesso archivistico, deve&#x0a;
      obbligatoriamente essere presente un unico (non ripetibile)&#x0a;
      relations/relation[@relationtype = &quot;resourcerelation&quot;]/relationentry&#x0a;
      dove il @localtype del &lt;relationentry> vale &quot;ComplArchSovraordinato&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count( relations/relation[@relationtype = 'resourcerelation']
                          /relationentry[@localtype = 'ComplArchSovraordinato'])"/>
        <!-- spostato in c.base
        <xs:assert xa:message="[&#x0a;&#x0a;
M049: In &lt;c>, quando rappresenta un complesso archivistico, deve essere&#x0a;
      presente, al più, un unico did/langmaterial/language/@lang
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/langmaterial/language/@lang)"/>
          -->
        <xs:assert test="1 >= count(e3:userestrict)"/> <!-- ??? -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M178: In &lt;c>, quando rappresenta un complesso archivistico, è ammesso, al più,&#x0a;
      un unico figlio &lt;scopecontent> con @localtype pari a&#x0a;
      &quot;AmbitiEContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'AmbitiEContenuto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M179: In &lt;c>, quando rappresenta un complesso archivistico, l'eventuale figlio&#x0a;
      &lt;scopecontent>, con @localtype pari a &quot;AmbitiEContenuto&quot;, deve avere&#x0a;
      almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent[@localtype = 'AmbitiEContenuto']
                satisfies $s/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M180: In &lt;c>, quando rappresenta un complesso archivistico, gli eventuali&#x0a;
      figli &lt;scopecontent> devono avere @localtype pari a &quot;AmbitiEContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent
                satisfies $s/@localtype = 'AmbitiEContenuto'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M304: In &lt;c>, quando rappresenta un complesso archivistico, gli eventuali&#x0a;
      valori di&#x0a;
       relations/relation[@relationtype = &quot;cpfrelation&quot;]&#x0a;
      /relationentry/@localtype&#x0a;
      devono soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $type in ( relations/relation[@relationtype = 'cpfrelation']
                                /relationentry/@localtype)
                satisfies $type = ('Soggetto conservatore', 'Soggetto vigilante', 'Proprietario',
                                   'Possessore', 'Detentore di diritti', 'Soggetto produttore')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M001: creato il tipo "c.arch" -->
  <xs:complexType name="c.arch">
    <xs:complexContent>
      <xs:extension base="c.base">
        <xs:assert xa:message="[&#x0a;&#x0a;
M020: In &lt;c>, quando rappresenta un'unità archivistica, è ammesso, al più, un&#x0a;
      unico figlio &lt;scopecontent> con @localtype pari a &quot;DescrizioneContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'DescrizioneContenuto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M021: In &lt;c>, quando rappresenta un'unità archivistica, l'eventuale figlio&#x0a;
      &lt;scopecontent>, con @localtype pari a &quot;DescrizioneContenuto&quot;, deve avere&#x0a;
      almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent[@localtype = 'DescrizioneContenuto']
                satisfies $s/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M050: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      obbligatioriamente presente uno e un solo (non ripetibile)&#x0a;
      did/unitid[@localtype = &quot;NumeroSequenza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(did/unitid[@localtype = 'NumeroSequenza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M051: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/unitid[@localtype = &quot;NumOrdinamentoProvvisorio&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'NumOrdinamentoProvvisorio'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M052: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/unitid[@localtype = &quot;NumOrdinamentoDefinitivo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'NumOrdinamentoDefinitivo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M053: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;Segnatura&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'Segnatura'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M054: In &lt;c>, quando rappresenta un'unità archivistica, se sono presenti dei&#x0a;
      did/unitid[@localtype = &quot;SegnaturaPrecedente&quot;], allora in &lt;unitid> deve&#x0a;
      essere presente anche @localtype
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $unitid in did/unitid[@label = 'SegnaturaPrecedente']
                satisfies $unitid/@localtype"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M055: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico &lt;fileplan>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(fileplan)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M056: In &lt;c>, quando rappresenta un'unità archivistica, l'eventuale figlio&#x0a;
      &lt;fileplan> deve avere almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (fileplan) then fileplan/p else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M057: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      fileplan/p/subject[@localtype = &quot;IndiceClassificazione&quot;]/@identifier
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(fileplan/p/subject[@localtype = 'IndiceClassificazione']/@identifier)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M058: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;TitoloOriginale&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'TitoloOriginale'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M059: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;IntegrazioneTitolo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'IntegrazioneTitolo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M060: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;TitoloAttribuito&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'TitoloAttribuito'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M061: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente almeno uno tra did/unittitle[@localtype = &quot;TitoloOriginale&quot;] e&#x0a;
      tra did/unittitle[@localtype = &quot;TitoloAttribuito&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="   did/unittitle[@localtype = 'TitoloOriginale']
                or did/unittitle[@localtype = 'TitoloAttribuito']"/>
        <!--
        <xs:assert test="1 >= count(e3:did/e3:physdescstructured/e3:genreform/e3:part[@localtype = 'Tipologia'])"/>
        -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M062: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;Supporto&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'Supporto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M063: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Altezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Altezza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M064: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Larghezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Larghezza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M065: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Spessore&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Spessore'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M066: In &lt;c>, quando rappresenta un'unità archivistica, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;Legatura&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'Legatura'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M069: In &lt;c>, quando rappresenta un'unità archivistica, deve&#x0a;
      obbligatoriamente essere presente un unico (non ripetibile)&#x0a;
      relations/relation[@relationtype = &quot;resourcerelation&quot;]/relationentry&#x0a;
      dove il @localtype del &lt;relationentry> vale &quot;LivelloSuperiore&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count( relations/relation[@relationtype = 'resourcerelation']
                          /relationentry[@localtype = 'LivelloSuperiore'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M079: In &lt;c>, quando rappresenta un'unità archivistica, se sono presenti dei&#x0a;
      relations/relation[@relationtype = &quot;cpfrelation&quot;], allora il valore degli&#x0a;
      @arcrole dei &lt;relation> devono soddisfare una precisa lista chiusa di&#x0a;
      valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $relation in relations/relation[@relationtype = 'cpfrelation']
                satisfies $relation/@arcrole = ('Destinatario', 'Mittente', 'Notaio', 'Testimone',
                                                'Autore', 'Disegnatore', 'Editore', 'Incisore',
                                                'Giudice', 'Agrimensore', 'Rilevatore', 'Miniaturista',
                                                'Copista', 'Esecutore', 'Progettista', 'Supervisore',
                                                'Litografo', 'Fotografo inventore', 'Fotografo principale',
                                                'Ideatore', 'Regista', 'Committente', 'Corrispondente',
                                                'Curatore', 'Responsabile', 'Partecipante', 'Finanziatore',
                                                'Possessore', 'Proprietario', 'Detentore dei diritti')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M181: In &lt;c>, quando rappresenta un'unità archivistica, gli eventuali&#x0a;
      figli &lt;scopecontent> devono avere @localtype pari a&#x0a;
      &quot;DescrizioneContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent
                satisfies $s/@localtype = 'DescrizioneContenuto'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M309: In &lt;c>, quando rappresenta un'unità archivistica, l'eventuale figlio&#x0a;
      &lt;fileplan> non deve avere più di un figlio &lt;p> con contenuto testuale&#x0a;
      non nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (fileplan) then 1 >= count(fileplan/p[normalize-space()]) else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M310: In &lt;c>, quando rappresenta un'unità archivistica, l'eventuale figlio&#x0a;
      &lt;fileplan> non deve avere più di un figlio &lt;p> che contiene, a sua&#x0a;
      volta, un figlio &lt;subject>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (fileplan) then 1 >= count(fileplan/p[subject]) else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M311: In &lt;c>, quando rappresenta un'unità archivistica, l'eventuale figlio&#x0a;
      &lt;fileplan> non deve contenere nessun figlio &lt;p> con contenuto testuale&#x0a;
      non nullo e, contemporaneamente, un figlio &lt;subject>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (fileplan) then not(fileplan/p[subject and normalize-space()]) else true()"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- M001: creato il tipo "c.docu" -->
  <xs:complexType name="c.docu">
    <xs:complexContent>
      <xs:extension base="c.base">
        <xs:assert xa:message="[&#x0a;&#x0a;
M020: In &lt;c>, quando rappresenta un'unità documentale, è ammesso, al più, un&#x0a;
      unico figlio &lt;scopecontent> con @localtype pari a &quot;DescrizioneContenuto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'DescrizioneContenuto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M021: In &lt;c>, quando rappresenta un'unità documentale, l'eventuale figlio&#x0a;
      &lt;scopecontent>, con @localtype pari a &quot;DescrizioneContenuto&quot;, deve avere&#x0a;
      almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent[@localtype = 'DescrizioneContenuto']
                satisfies $s/p"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M050: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      obbligatioriamente presente uno e un solo (non ripetibile)&#x0a;
      did/unitid[@localtype = &quot;NumeroSequenza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count(did/unitid[@localtype = 'NumeroSequenza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M051: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/unitid[@localtype = &quot;NumOrdinamentoProvvisorio&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'NumOrdinamentoProvvisorio'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M052: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/unitid[@localtype = &quot;NumOrdinamentoDefinitivo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'NumOrdinamentoDefinitivo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M053: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;Segnatura&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'Segnatura'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M054: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      did/unitid[@localtype = &quot;SegnaturaPrecedente&quot;], allora in &lt;unitid> deve&#x0a;
      essere presente anche @localtype
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $unitid in did/unitid[@label = 'SegnaturaPrecedente']
                satisfies $unitid/@localtype"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M058: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;TitoloOriginale&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'TitoloOriginale'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M059: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;IntegrazioneTitolo&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'IntegrazioneTitolo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M060: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico did/unitid[@localtype = &quot;TitoloAttribuito&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'TitoloAttribuito'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M061: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente almeno uno tra did/unittitle[@localtype = &quot;TitoloOriginale&quot;] e&#x0a;
      tra did/unittitle[@localtype = &quot;TitoloAttribuito&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="   did/unittitle[@localtype = 'TitoloOriginale']
                or did/unittitle[@localtype = 'TitoloAttribuito']"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M062: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;Supporto&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'Supporto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M063: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Altezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Altezza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M064: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Larghezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Larghezza'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M065: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Spessore&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Spessore'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M066: In &lt;c>, quando rappresenta un'unità documentale, deve essere&#x0a;
      presente, al più, un unico&#x0a;
      did/physdescstructured/physfacet[@localtype = &quot;Legatura&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/physfacet[@localtype = 'Legatura'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M069: In &lt;c>, quando rappresenta un'unità documentale, deve&#x0a;
      obbligatoriamente essere presente un unico (non ripetibile)&#x0a;
      relations/relation[@relationtype = &quot;resourcerelation&quot;]/relationentry&#x0a;
      dove il @localtype del &lt;relationentry> vale &quot;LivelloSuperiore&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 = count( relations/relation[@relationtype = 'resourcerelation']
                          /relationentry[@localtype = 'LivelloSuperiore'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M070: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/genreform dove il&#x0a;
      @physdescstructuredtype di &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype del &lt;physfacet> vale &quot;TipologiaDocumentaria&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet[@localtype = 'TipologiaDocumentaria']/genreform)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M071: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/genreform/part dove il&#x0a;
      @physdescstructuredtype di &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @localtype del &lt;physfacet> vale &quot;TipologiaDocumentaria&quot; e&#x0a;
      dove il @localtype del &lt;part> vale &quot;TracciatoSpecifico&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet[@localtype = 'TipologiaDocumentaria']/genreform
                           /part[@localtype = 'TracciatoSpecifico'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M072: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      did/physdescstructured/physfacet/genreform/part dove i&#x0a;
      @physdescstructuredtype di &lt;physdescstructured> valgono &quot;materialtype&quot;,&#x0a;
      dove i @localtype dei &lt;physfacet> valgono &quot;TipologiaDocumentaria&quot; e&#x0a;
      dove i @localtype dei &lt;part> valgono &quot;TracciatoSpecifico&quot;, allora i&#x0a;
      contenuti dei &lt;part> devono soffisfare una lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet[@localtype = 'TipologiaDocumentaria']/genreform
                               /part[@localtype = 'TracciatoSpecifico']
                satisfies $part/text() = ('Audiovisivo', 'Cartografia', 'Carteggio', 'Fotografia',
                                          'Grafica', 'Manoscritto', 'Pergamena')"/>
        <!-- m060: disattivato (?)
        <xs:assert test="1 >= count(e3:itemplan/e3:p/e3:subject[@localtype= 'classificazione']/@identifier)"/>
        -->
        <!--
        <xs:assert test="1 >= count(e3:did/e3:physdescstructured/e3:genreform/e3:part[@localtype = 'Tipologia'])"/>
        -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M073: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      did/physdescstructured/physfacet/genreform/part dove i @localtype dei&#x0a;
      &lt;physfacet> valgono &quot;Sigillo&quot; e dove i @localtype dei &lt;part> valgono&#x0a;
      &quot;Natura&quot;, allora i contenuti dei &lt;part> devono soffisfare una precisa&#x0a;
      lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured/physfacet[@localtype = 'Sigillo']/genreform
                               /part[@localtype = 'Natura']
                satisfies $part/text() = ('Sigillo a una faccia', 'Sigillo a due facce', 'Bolla',
                                          'Sigillo con controsigillo', 'Timbro a umido', 'Timbro a secco',
                                          'Sigillo deperdito')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M074: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      did/physdescstructured/physfacet/genreform/part dove i @localtype di&#x0a;
      &lt;physfacet> valgono &quot;Sigillo&quot; e dove i @localtype dei &lt;part> valgono&#x0a;
      &quot;Materiale&quot;, allora i contenuti dei &lt;part> devono soffisfare una precisa&#x0a;
      lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured/physfacet[@localtype = 'Sigillo']/genreform
                               /part[@localtype = 'Materiale']
                satisfies $part/text() = ('Argilla', 'Cera', 'Ceralacca', 'Oro', 'Piombo', 'Argento',
                                          'Carta', 'Cera sotto carta', 'Inchiostro')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M075: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      did/physdescstructured/physfacet/genreform/part dove i @localtype dei&#x0a;
      &lt;physfacet> valgono &quot;Sigillo&quot; e dove i @localtype dei &lt;part> valgono&#x0a;
      &quot;ModoApposizione&quot;, allora i contenuti dei &lt;part> devono soddisfare una&#x0a;
      precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured/physfacet[@localtype = 'Sigillo']/genreform
                               /part[@localtype = 'ModoApposizione']
                satisfies $part/text() = ('Aderente', 'Aderente incassato', 'Aderente su coda semplice',
                                          'Aderente su coda parigina', 'Aderente en placard', 'Pendente')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M079: In &lt;c>, quando rappresenta un'unità documentale, se sono presenti dei&#x0a;
      relations/relation[@relationtype = &quot;cpfrelation&quot;], allora il valore degli&#x0a;
      @arcrole dei &lt;relation> devono soddisfare una precisa lista chiusa di&#x0a;
      valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $relation in relations/relation[@relationtype = 'cpfrelation']
                satisfies $relation/@arcrole = ('Destinatario', 'Mittente', 'Notaio', 'Testimone',
                                                'Autore', 'Disegnatore', 'Editore', 'Incisore',
                                                'Giudice', 'Agrimensore', 'Rilevatore', 'Miniaturista',
                                                'Copista', 'Esecutore', 'Progettista', 'Supervisore',
                                                'Litografo', 'Fotografo inventore', 'Fotografo principale',
                                                'Ideatore', 'Regista', 'Committente', 'Corrispondente',
                                                'Curatore', 'Responsabile', 'Partecipante', 'Finanziatore',
                                                'Possessore', 'Proprietario', 'Detentore dei diritti')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M084: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/didnote[@localtype = &quot;NoteDorsali&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/didnote[@localtype = 'NoteDorsali'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M085: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/didnote[@localtype = &quot;NoteDorsali&quot;], allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Pergamena&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/didnote[@localtype = 'NoteDorsali'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Pergamena'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M086: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/materialspec[@label = &quot;Colore&quot;], allora l'unità documentale deve&#x0a;
      rappresentare o una &quot;Cartografia&quot;, o un &quot;Audiovisivo&quot;, o una&#x0a;
      &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/materialspec[@label = 'Colore'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = ('Cartografia', 'Audiovisivo', 'Grafica')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M087: In &lt;c>, quando rappresenta una &quot;Cartografia&quot;, se è presente un&#x0a;
      did/materialspec[@label = &quot;Colore&quot;], allora il contenuto del&#x0a;
      &lt;materialspec> deve soddisfare una ben precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia')
                then every $mat in did/materialspec[@label = 'Colore']
                     satisfies $mat/text() = ('Bianco e nero', 'Misto', 'Monocromatico', 'Multicolore')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M088: In &lt;c>, quando rappresenta una &quot;Grafica&quot;, se è presente un&#x0a;
      did/materialspec[@label = &quot;Colore&quot;], allora il contenuto del&#x0a;
      &lt;materialspec> deve soddisfare una ben precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Grafica')
                then every $mat in did/materialspec[@label = 'Colore']
                     satisfies $mat/text() = ('Altro', 'Bianco e nero', 'Colorato a mano', 'Misto',
                                              'Monocromatico', 'Multicolore')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M089: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/materialspec[@label = &quot;Formato&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/materialspec[@label = 'Formato'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M090: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/materialspec[@label = &quot;Formato&quot;], allora l'unità documentale deve&#x0a;
      rappresentare un &quot;AudiovisivoPergamena&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/materialspec[@label = 'Formato'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Audiovisivo'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M091: In &lt;c>, se è presente un did/materialspec[@label = &quot;Formato&quot;], allora il&#x0a;
      contenuto del &lt;materialspec> deve soddisfare una ben precisa lista chiusa&#x0a;
      di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $mat in did/materialspec[@label = 'Formato']
                satisfies $mat/text() = ('AVI', 'MPEG-4', 'MOV', 'MP3', 'WAW')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M092: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/materialspec[@label = &quot;Materia&quot;], allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/materialspec[@label = 'Materia'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Grafica'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M093: In &lt;c>, se è presente un did/materialspec[@label = &quot;Materia&quot;], allora il&#x0a;
      contenuto del &lt;materialspec> deve soddisfare una ben precisa lista chiusa&#x0a;
      di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $mat in did/materialspec[@label = 'Materia']
                satisfies $mat/text() = ('Altro', 'Carta', 'Carta giapponese', 'Carta velina',
                                         'Carta oliata', 'Carta paglierina', 'Carta patinata',
                                         'Carta pergamena', 'Carta quadrettata', 'Carta timbrata',
                                         'Carta tinta', 'Carta velina', 'Carta vellutata',
                                         'Carta vergata', 'Cartoncino', 'Cartoncino bianco',
                                         'Cartoncino colorato', 'Cartoncino da spolvero',
                                         'Pergamena', 'Cartone', 'Cera', 'Cuoio', 'Gesso', 'Legno',
                                         'Metallo', 'Seta', 'Tela', 'Tessuto Vetro', 'Carta telata',
                                         'Carta da lucido', 'Carta millimetrata', 'Radex',
                                         'Item/supporto elettronico', 'Supporti misti')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M094: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/materialspec con @localtype pari o&#x0a;
      ad &quot;Angolare&quot; o a &quot;Lineare&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/materialspec[@localtype = ('Angolare', 'Lineare')])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M095: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/materialspec con @localtype o pari ad &quot;Angolare&quot; o a &quot;Lineare&quot;,&#x0a;
      allora l'unità documentale deve rappresentare o una &quot;Cartografia&quot; o una&#x0a;
      &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/materialspec[@localtype = ('Angolare', 'Lineare')])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = ('Cartografia', 'Grafica')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M096: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/materialspec[@label = &quot;Orientamento&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/materialspec[@localtype = 'Orientamento'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M097: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/materialspec[@label = &quot;Orientamento&quot;], allora l'unità documentale&#x0a;
      deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/materialspec[@label = 'Orientamento'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M098: In &lt;c>, se è presente un did/materialspec[@label = &quot;Orientamento&quot;],&#x0a;
      allora il contenuto del &lt;materialspec> deve soddisfare una ben precisa&#x0a;
      lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $mat in did/materialspec[@localtype = 'Orientamento']
                satisfies $mat/text() = ('Nord', 'Sud', 'Est', 'Ovest', 'Nord-Est',
                                         'Nord-Ovest', 'Sud-Est', 'Sud-Ovest')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M099: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/descriptivenote/p/geogname, dove il @localtype di&#x0a;
      &lt;geogname> è pari a &quot;LuogoRappresentato&quot;], allora l'unità documentale&#x0a;
      deve rappresentare o una &quot;Cartografia&quot;, o una &quot;Fotografia&quot;, o una&#x0a;
      &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $geo in  did/physdescstructured/descriptivenote/p
                              /geogname[@localtype = 'LuogoRappresentato']
                satisfies    did/physdescstructured[@physdescstructuredtype = 'materialtype']
                            /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                            /part[@localtype = 'TracciatoSpecifico']/text()
                          = ('Cartografia', 'Fotografia', 'Grafica')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M100: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/descriptivenote/p/quote[@localtype = &quot;Explicit&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/descriptivenote/p/quote[@localtype = 'Explicit'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M101: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/descriptivenote/p/quote[@localtype = &quot;Explicit&quot;],&#x0a;
      allora l'unità documentale deve rappresentare un &quot;Manoscritto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $quote in did/physdescstructured/descriptivenote/p/quote[@localtype = 'Explicit']
                satisfies  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                          /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                          /part[@localtype = 'TracciatoSpecifico']/text() = 'Manoscritto'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M102: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/descriptivenote/p/quote[@localtype = &quot;Implicit&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/descriptivenote/p/quote[@localtype = 'Implicit'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M103: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/descriptivenote/p/quote[@localtype = &quot;Implicit&quot;],&#x0a;
      allora l'unità documentale deve rappresentare un &quot;Manoscritto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $quote in did/physdescstructured/descriptivenote/p/quote[@localtype = 'Implicit']
                satisfies  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                          /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                          /part[@localtype = 'TracciatoSpecifico']/text() = 'Manoscritto'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M104: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/descriptivenote/p/subject, dove il @localtype di&#x0a;
      &lt;subject> è pari a &quot;Occasione&quot;], allora l'unità documentale&#x0a;
      deve rappresentare una &quot;Fotografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $quote in did/physdescstructured/descriptivenote/p/subject[@localtype = 'Occasione']
                satisfies  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                          /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                          /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia'"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M105: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)
      did/physdescstructured/dimensions[@localtype = &quot;Altezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured/dimensions[@localtype = 'Altezza'])"/>
        <!-- assert annullato poiche' risultato errato  
        <xs:assert xa:message="[&#x0a;&#x0a;
M106: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;dimensions> vale &quot;Altezza&quot;, allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /dimensions[@localtype = 'Altezza'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
                -->
        <!-- assert annullato poiche' risultato errato  
        <xs:assert xa:message="[&#x0a;&#x0a;
M107: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;dimensions> vale &quot;Altezza&quot;, allora &lt;dimensions> deve avere @unit con&quot;
      valore non nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $dim in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                              /dimensions[@localtype = 'Altezza']
                satisfies $dim/@unit != ''"/>
                -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M108: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Altezza&quot;], allora&#x0a;
      &lt;dimensions> deve avere contenuto non nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $dim in did/physdescstructured/dimensions[@localtype = 'Altezza']
                satisfies $dim/text() != ''"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M109: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)
      did/physdescstructured/dimensions[@localtype = &quot;Larghezza&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/physdescstructured/dimensions[@localtype = 'Larghezza'])"/>
        <!-- assert annullato poiche' risultato errato  
        <xs:assert xa:message="[&#x0a;&#x0a;
M110: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;dimensions> vale &quot;Larghezza&quot;, allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /dimensions[@localtype = 'Larghezza'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
                -->
        <!-- assert annullato poiche' risultato errato  
        <xs:assert xa:message="[&#x0a;&#x0a;
M111: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;dimensions> vale &quot;Larghezza&quot;, allora &lt;dimensions> deve avere @unit con&quot;
      valore non nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $dim in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                              /dimensions[@localtype = 'Larghezza']
                satisfies $dim/@unit != ''"/>
                -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M112: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/dimensions[@localtype = &quot;Larghezza&quot;], allora&#x0a;
      &lt;dimensions> deve avere contenuto&quot; non nullo
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $dim in did/physdescstructured/dimensions[@localtype = 'Larghezza']
                satisfies $dim/text() != ''"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M113: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/physdescstructured/physfacet, dove&#x0a;
      il @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;&#x0a;
      e dove il @localtype del &lt;physfacet> vale &quot;AStampa&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet[@localtype = 'AStampa'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M114: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;AStampa&quot;, allora l'unità documentale deve rappresentare&#x0a;
      una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet[@localtype = 'AStampa'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M115: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;AStampa&quot;, allora il contenuto di &lt;physfacet> deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet[@localtype = 'AStampa']
                satisfies $phys/text() = ('SI', 'NO')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M116: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;MediazioniGrafiche&quot;, allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet[@localtype = 'MediazioniGrafiche'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M117: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;MediazioniGrafiche&quot;, allora il contenuto di &lt;physfacet>&#x0a;
      deve soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet[@localtype = 'MediazioniGrafiche']
                satisfies $phys/text() = ('Matita', 'Inchiostri policromi', 'Inchiostro nero',
                                          'Acquerello', 'Tempera', 'Sanguigna', 'Tecnica mista',
                                          'Penna')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M118: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/physdescstructured/physfacet, dove&#x0a;
      il @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;&#x0a;
      e dove il @localtype del &lt;physfacet> vale &quot;RappresentazioneTematica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet[@localtype = 'RappresentazioneTematica'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M119: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;RappresentazioneTematica&quot;, allora l'unità documentale&#x0a;
      deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet[@localtype = 'RappresentazioneTematica'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M120: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;RappresentazioneTematica&quot;, allora il contenuto di&#x0a;
      &lt;physfacet> deve soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet[@localtype = 'RappresentazioneTematica']
                satisfies $phys/text() = ('Carta celeste', 'Carta geografica', 'Carta geologica',
                                          'Carta idrografica', 'Carta corografica', 'Carta militare',
                                          'Carta mineralogica', 'Carta nautica', 'Carta topografica',
                                          'Mappa catastale', 'Carta IGM')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M121: In &lt;c>, quando rappresenta un'unità documentale di tipo &quot;Cartografia&quot; o&#x0a;
      &quot;Fotografia&quot;, deve essere presente, al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Tecnica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = ('Cartografia', 'Fotografia'))
                then (1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                 /physfacet[@localtype = 'Tecnica']))
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M122: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Tecnica&quot;, allora l'unità documentale deve rappresentare&#x0a;
      o una &quot;Cartografia&quot;, o un &quot;Audiovisivo&quot;, o una &quot;Fotografia&quot;, o una&#x0a;
      &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet[@localtype = 'Tecnica'])
                then    did/physdescstructured[@physdescstructuredtype = 'materialtype']
                       /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                       /part[@localtype = 'TracciatoSpecifico']/text()
                     = ('Cartografia', 'Audiovisivo', 'Fotografia', 'Grafica')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M123: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Tecnica&quot;, allora, quando l'unita' documentale&#x0a;
      rappresenta una &quot;Cartografia&quot;, il contenuto di &lt;physfacet> deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia')
                then every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet[@localtype = 'Tecnica']
                     satisfies $phys/text() = ('Acquaforte', 'Cianografia', 'Disegno', 'Eliografia',
                                               'Fotoincisione', 'Fotolitografia', 'Ignoto', 'Incisione',
                                               'Litografia', 'Manoscritto', 'Serigrafia', 'Xilografia')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M124: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Tecnica&quot;, allora, quando l'unita' documentale&#x0a;
      rappresenta una &quot;Cartografia&quot;, il contenuto di &lt;physfacet> deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia')
                then every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet[@localtype = 'Tecnica']
                     satisfies   $phys/text()
                               = ('Albumina', 'Aristotipo', 'Autocromia / vetro',
                                  'Bromolio', 'Calotipo', 'Carbone', 'Carta celloidina',
                                  'Carta salata', 'Cianotipo', 'Collodio', 'Collodio matt',
                                  'Collotipia', 'Dagherrotipo', 'Disegno', 'Documento',
                                  'Fotocromolitografia', 'Fotografia digitale', 'Fotoincisione',
                                  &quot;Gelatina ai sali d'argento&quot;,
                                  &quot;Gelatina ai sali d'argento / carta&quot;,
                                  &quot;Gelatina ai sali d'argento / pellicola&quot;,
                                  &quot;Gelatina ai sali d'argento / pellicola (acetati)&quot;,
                                  &quot;Gelatina ai sali d'argento / pellicola (nitrato)&quot;,
                                  &quot;Gelatina ai sali d'argento / pellicola (poliestere)&quot;,
                                  &quot;Gelatina ai sali d'argento / vetro&quot;, 'Kallytipo',
                                  'Platinotipo', 'Processi a sviluppo cromogeno',
                                  'Stampa ai pigmenti', 'Stampa digitale', 'Stampa fotomeccanica',
                                  &quot;Stampa a getto d'inchiostro&quot;, 'Stampa tipografica',
                                  'Stampa tipografica a mezzitoni', 'Woodburytipia')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M125: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Tecnica&quot;, allora, quando l'unita' documentale&#x0a;
      rappresenta una &quot;Grafica&quot;, il contenuto di &lt;physfacet> deve soddisfare&#x0a;
      una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia')
                then every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet[@localtype = 'Tecnica']
                     satisfies $phys/text() = ('Acquaforte', 'Acquerello', 'Acquatina', 'Algrafia', 'Altro',
                                               'Blu print', 'Bulino', 'Calcografia', 'Camaïeu', 'Carborundum',
                                               'Chiaroscuro', 'Cliché-verre', 'Collage', 'Collografia',
                                               'Coloritura', 'Computergrafica', 'Cromolitografia',
                                               'Cromozincografia', 'Doratura', 'Eliografia', 'Eliotipia',
                                               'Fotoincisione', 'Fotolitografia', 'Gipsografia', 'Lavis',
                                               'Linoleografia', 'Litografia', 'Offset', 'Oleografia',
                                               'Pochoir', 'Puntasecca', 'Serigrafia', 'Stampa tipografica',
                                               'Vernice molle', 'Vitrografia', 'Xilografia')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M126: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/genreform/@relator)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M127: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator, allora l'unità documentale deve&#x0a;
      rappresentare o una &quot;Cartografia&quot;, o un &quot;Audiovisivo&quot;, o una&#x0a;
      &quot;Fotografia&quot;, o una &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@relator])
                then    did/physdescstructured[@physdescstructuredtype = 'materialtype']
                       /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                       /part[@localtype = 'TracciatoSpecifico']/text()
                     = ('Cartografia', 'Audiovisivo', 'Fotografia', 'Grafica')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M128: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator, allora, quando l'unità&#x0a;
      documentale rappresenta una &quot;Cartografia&quot;, il contenuto di @relator deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia')
                then every $genr in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet/genreform[@relator]
                     satisfies $genr/@relator = ('Atlante', 'Mappa', 'Modello', 'Pianta', 'Profilo',
                                                 'Sezione', 'Veduta', 'Planimetria', 'Planivolumetria',
                                                 'Planisfero', &quot;Vista a volo d'uccello&quot;,
                                                 'Veduta prospettica', 'Veduta assonometrica',
                                                 'Studio/schizzo', 'Prospetto', 'Rilievo')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M129: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator, allora, quando l'unità&#x0a;
      documentale rappresenta un &quot;Audiovisivo&quot;, il contenuto di @relator deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Audiovisivo')
                then every $genr in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet/genreform[@relator]
                     satisfies $genr/@relator = ('Documentario', 'Film', 'Intervista',
                                                 'Presentazione', 'Videointervista')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M130: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator, allora, quando l'unità&#x0a;
      documentale rappresenta una &quot;Fotografia&quot;, il contenuto di @relator deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia')
                then every $genr in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet/genreform[@relator]
                     satisfies $genr/@relator = ('Negativo', 'Positivo', 'Diapositiva', 'Unicum',
                                                 'Fotografia virtuale', 'Materiale vario')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M131: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il &lt;genreform> contiene un @relator, allora, quando l'unità&#x0a;
      documentale rappresenta una &quot;Grafica&quot;, il contenuto di @relator deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                    /part[@localtype = 'TracciatoSpecifico']/text() = 'Grafica')
                then every $genr in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /physfacet/genreform[@relator]
                     satisfies $genr/@relator = ('Biglietto da visita', 'Disegno', 'Disegno tecnico',
                                                 'Illustrazione', 'Stampa', 'Disegno artistico')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M132: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/genreform/part, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype di &lt;genreform> vale &quot;StadioDocumento&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/genreform[@localtype = 'StadioDocumento']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M133: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform/part, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype di &lt;genreform> vale &quot;StadioDocumento&quot;, allora l'unità&#x0a;
      documentale deve rappresentare o un &quot;Manoscritto&quot;, o una &quot;Pergamena&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'StadioDocumento']/part)
                then    did/physdescstructured[@physdescstructuredtype = 'materialtype']
                       /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                       /part[@localtype = 'TracciatoSpecifico']/text()
                     = ('Manoscritto', 'Pergamena')
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M134: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype del &lt;genreform> vale &quot;StadioDocumento&quot;, allora il&#x0a;
      contenuto del &lt;part> deve soddisfare una precisa lista chiusa di valori&#x0a;
      ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet/genreform[@localtype = 'StadioDocumento']/part
                satisfies $part/text() = ('Minuta', 'Originale', 'Copia autentica',
                                          'Copia semplice', 'Copia tarda', 'Copia coeva')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M135: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/genreform/part, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype di &lt;genreform> vale &quot;StatoRedazione&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/genreform[@localtype = 'StatoRedazione']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M136: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform/part, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype di &lt;genreform> vale &quot;StatoRedazione&quot;, allora l'unità&#x0a;
      documentale deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/genreform[@localtype = 'StatoRedazione']/part)
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M137: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/genreform, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot; e&#x0a;
      dove il @localtype del &lt;genreform> vale &quot;StatoRedazione&quot;, allora il&#x0a;
      contenuto del &lt;part> deve soddisfare una precisa lista chiusa di valori&#x0a;
      ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $part in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet/genreform[@localtype = 'StatoRedazione']/part
                satisfies $part/text() = ('Abbozzo', 'Minuta', 'Originale', 'Copia autentica',
                                          'Copia semplice', 'Copia tarda', 'Copia coeva')"/>
        <!-- m104: disattivato per cambio mappatura
        <xs:assert test="1 >= count( e3:did/e3:physdescstructured[@physdescstructuredtype = 'materialtype']
                                    /e3:physfacet/e3:geogname/e3:geographiccoordinates)"/>
                                    -->
        <!-- m105: disattivato per cambio mappatura
        <xs:assert test="every $geog in  e3:did/e3:physdescstructured[@physdescstructuredtype = 'materialtype']
                                        /e3:physfacet/e3:geogname/e3:geographiccoordinates
                         satisfies     ( e3:did/e3:physdescstructured[@physdescstructuredtype = 'materialtype']
                                        /e3:physfacet/e3:genreform[@localtype = 'TipologiaDocumentaria']
                                        /e3:part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia')
                                   and ($geog/text() != '')"/>
                                    -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M138: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/unitdatestructured/datesingle[@localtype = &quot;DataRipresa&quot;], allora&#x0a;
      l'unità documentale deve rappresentare una &quot;Fotografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/unitdatestructured/datesingle[@localtype = 'DataRipresa'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M139: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile) did/unitid[@localtype = &quot;NumeroTavola&quot;]
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(did/unitid[@localtype = 'NumeroTavola'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M140: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/unitid[@localtype = &quot;NumeroTavola&quot;], allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (did/unitid[@localtype = 'NumeroTavola'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M141: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      scopecontent[@localtype = &quot;SoggettoIdentificato&quot;], o figlio di &lt;c>, o&#x0a;
      discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= (  count(scopecontent[@localtype = 'SoggettoIdentificato'])
                      + count(scopecontent//scopecontent[@localtype = 'SoggettoIdentificato']))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M142: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      scopecontent[@localtype = &quot;SoggettoIdentificato&quot;], o figlio di &lt;c>, o&#x0a;
      discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>, allora l'unità&#x0a;
      documentale deve rappresentare una &quot;Fotografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (   scopecontent[@localtype = 'SoggettoIdentificato']
                    or scopecontent//scopecontent[@localtype = 'SoggettoIdentificato'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M143: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      scopecontent[@localtype = &quot;SoggettoIdentificato&quot;]/p/subject/part, o con&#x0a;
      lo &lt;scopecontent> figlio di &lt;c>, o discendente di un ulteriore&#x0a;
      &lt;scopecontent>, figlio di &lt;c>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= (  count( scopecontent[@localtype = 'SoggettoIdentificato']
                              /p/subject/part)
                      + count( scopecontent//scopecontent[@localtype = 'SoggettoIdentificato']
                              /p/subject/part))"/>
        <!-- m112 rimosso (superfluo, in presenza di M142)
        <xs:assert test="every $part in ( e3:scopecontent[@localtype = 'SoggettoIdentificato']
                                         /e3:p/e3:subject/e3:part,
                                          e3:scopecontent//e3:scopecontent[@localtype = 'SoggettoIdentificato']
                                         /e3:p/e3:subject/e3:part)
                         satisfies  e3:did/e3:physdescstructured[@physdescstructuredtype = 'materialtype']
                                   /e3:physfacet/e3:genreform[@localtype = 'TipologiaDocumentaria']
                                   /e3:part[@localtype = 'TracciatoSpecifico']/text() = 'Fotografia'"/>
                                   -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M144: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Esecuzione&quot;, allora l'unità documentale deve&#x0a;
      rappresentare una &quot;Grafica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet[@localtype = 'Esecuzione'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Grafica'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M145: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet, dove il @physdescstructuredtype del&#x0a;
      &lt;physdescstructured> vale &quot;materialtype&quot; e dove il @localtype del&#x0a;
      &lt;physfacet> vale &quot;Esecuzione&quot;, allora il contenuto del &lt;physfacet> deve&#x0a;
      soddisfare una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $phys in  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                               /physfacet[@localtype = 'Esecuzione']
                satisfies $phys/text() = ('Mano libera', 'Tecnigrafo',
                                          'Elaborazione elettronica/digitale')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M146: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      scopecontent[@localtype = &quot;NotaArchivisticoCodicologica&quot;], o figlio di&#x0a;
      &lt;c>, o discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= (  count(scopecontent[@localtype = 'NotaArchivisticoCodicologica'])
                      + count(scopecontent//scopecontent[@localtype = 'NotaArchivisticoCodicologica']))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M147: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      scopecontent[@localtype = &quot;NotaArchivisticoCodicologica&quot;], o figlio di&#x0a;
      &lt;c>, o discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>,&#x0a;
      allora l'unità documentale deve rappresentare un &quot;Manoscritto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (   scopecontent[@localtype = 'NotaArchivisticoCodicologica']
                    or scopecontent//scopecontent[@localtype = 'NotaArchivisticoCodicologica'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Manoscritto'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M148: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      scopecontent[@localtype = &quot;NotaArchivisticoDiplomatica&quot;], o figlio di&#x0a;
      &lt;c>, o discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= (  count(scopecontent[@localtype = 'NotaArchivisticoDiplomatica'])
                      + count(scopecontent//scopecontent[@localtype = 'NotaArchivisticoDiplomatica']))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M149: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      scopecontent[@localtype = &quot;NotaArchivisticoDiplomatica&quot;], o figlio di&#x0a;
      &lt;c>, o discendente di un ulteriore &lt;scopecontent>, figlio di &lt;c>,&#x0a;
      allora l'unità documentale deve rappresentare una &quot;Pergamena&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (   scopecontent[@localtype = 'NotaArchivisticoDiplomatica']
                    or scopecontent//scopecontent[@localtype = 'NotaArchivisticoDiplomatica'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Pergamena'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M150: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Latitudine&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                                     and @altrender = 'Latitudine'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M151: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Latitudine&quot;,&#x0a;
      allora l'unità documentale deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                              and @altrender = 'Latitudine'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M152: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Longitudine&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                                     and @altrender = 'Longitudine'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M153: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale&#x0a;
      &quot;Longitudine&quot;, allora l'unità documentale deve rappresentare una&#x0a;
      &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                              and @altrender = 'Longitudine'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M154: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Reticolo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                                     and @altrender = 'Reticolo'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M155: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Reticolo&quot;,&#x0a;
      allora l'unità documentale deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                              and @altrender = 'Reticolo'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M156: In &lt;c>, quando rappresenta un'unità documentale, deve essere presente,&#x0a;
      al più, un unico (non ripetibile)&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Proiezione&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                           /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                                     and @altrender = 'Proiezione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M157: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Proiezione&quot;,&#x0a;
      allora l'unità documentale deve rappresentare una &quot;Cartografia&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                    /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                              and @altrender = 'Proiezione'])
                then  did/physdescstructured[@physdescstructuredtype = 'materialtype']
                     /physfacet/genreform[@localtype = 'TipologiaDocumentaria']
                     /part[@localtype = 'TracciatoSpecifico']/text() = 'Cartografia'
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M158: In &lt;c>, quando rappresenta un'unità documentale, se è presente un&#x0a;
      did/physdescstructured/physfacet/geogname/geographiccoordinates, dove il&#x0a;
      @physdescstructuredtype del &lt;physdescstructured> vale &quot;materialtype&quot;,&#x0a;
      dove il @coordinatesystem del &lt;geographiccoordinates> vale &quot;WSG84&quot;, e&#x0a;
      dove l'@altrender del medesimo &lt;geographiccoordinates> vale &quot;Proiezione&quot;,&#x0a;
      allora il contenuto del &lt;geographiccoordinates> deve soddisfare una&#x0a;
      precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $geog in ( did/physdescstructured[@physdescstructuredtype = 'materialtype']
                                /physfacet/geogname/geographiccoordinates[    @coordinatesystem = 'WGS84'
                                                                          and @altrender = 'Proiezione'])
                satisfies $geog/text() = ('Proiezione azimutale', 'Proiezione cilindrica',
                                          'Proiezione conica', 'Proiezione prospettica',
                                          'Proiezione traversa di Mercatore UTM')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M182: In &lt;c>, quando rappresenta un'unità documentale, gli eventuali&#x0a;
      figli &lt;scopecontent> devono avere @localtype pari a&#x0a;
      &quot;SoggettoIdentificato&quot; a &quot;NotaArchivisticoCodicologica&quot; a&#x0a;
      &quot;NotaArchivisticoDiplomatica&quot; a &quot;DescrizioneContenuto&quot; a &quot;Regesto&quot; o a&#x0a;
      &quot;TrascrizioneEdizione&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="every $s in scopecontent
                satisfies $s/@localtype = ('SoggettoIdentificato', 'NotaArchivisticoCodicologica',
                                           'NotaArchivisticoDiplomatica', 'DescrizioneContenuto',
                                           'Regesto', 'TrascrizioneEdizione')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M183: In &lt;c>, quando rappresenta un'unità documentale, è ammesso, al più, un&#x0a;
      unico figlio &lt;scopecontent> con @localtype pari a &quot;Regesto&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'Regesto'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M184: In &lt;c>, quando rappresenta un'unità documentale, è ammesso, al più, un&#x0a;
      unico figlio &lt;scopecontent> con @localtype pari a &quot;TrascrizioneEdizione&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(scopecontent[@localtype = 'TrascrizioneEdizione'])"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M312: In &lt;c>, quando rappresenta un'unità documentale, è ammesso, al più, un&#x0a;
      fileplan/p/subject[@localtype = &quot;CodiceClassificazione&quot;]/@identifier
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count(fileplan/p/subject[@localtype = 'CodiceClassificazione']/@identifier)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M313: In &lt;c>, quando rappresenta un'unità documentale, è ammesso, al più, un&#x0a;
      fileplan/p/subject[@localtype = &quot;CodiceClassificazione&quot;]/part&#x0a;
      dove il @localtype del &lt;part> è pari a &quot;Qualifica&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 >= count( fileplan/p/subject[@localtype = 'CodiceClassificazione']
                           /part[@localtype = 'Qualifica'])"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- end ICAR extra types -->

  <!-- ELEMENTS -->
  <xs:element name="ead">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="control" type="control"/>
        <!-- M185: utilizzate le versioni di "archdesc" a seconda dei
                   valori di @level e @otherlevel -->
        <xs:element name="archdesc">
          <xs:alternative type="archdesc.prdg" test="    (@level = 'otherlevel')
                                                     and (@otherlevel = 'ProgettoDigitalizzazione')"/>
          <xs:alternative type="archdesc.prog" test="    (@level = 'otherlevel')
                                                     and (@otherlevel = 'Progetto')"/>
          <xs:alternative type="archdesc.strc" test="    (@level = 'otherlevel')
                                                     and (@otherlevel = 'StrumentoRicerca')"/>
          <xs:alternative type="archdesc.comp"/>
        </xs:element>
      </xs:sequence>
      <xs:attributeGroup ref="am.common"/>
      <xs:attribute name="relatedencoding" type="xs:token"/>
      <xs:attribute name="base" type="xs:anyURI"/>
      <!-- m005 (rimosso e sostituito da test specifici) -->
<!--      
      <xs:assert test="every $elem in (descendant::e3:processinfo[@localtype = 'statusScheda'], [sostituito]
                                       descendant::e3:scopecontent, [sostituito]
                                       descendant::e3:custodhist, [sostituito]
                                       descendant::e3:appraisal[@localtype = 'procedure_scarto'], [sostituito]
                                       descendant::e3:accruals, [sostituito]
                                       descendant::e3:acqinfo, [sostituito]
                                       descendant::e3:arrangement, [disattivato (m021)]
                                       descendant::e3:odd,
                                       descendant::e3:fileplan, [sostituito]
                                       descendant::e3:descriptivenote, [gia' previsto dallo schema originale]
                                       descendant::e3:accessrestrict, [sostituito]
                                       descendant::e3:userestrict)
                       satisfies ($elem/e3:p)"/>
                       -->
      <xs:assert xa:message="[&#x0a;&#x0a;
M002: &lt;ead> non può contenere più di un&#x0a;
      control/localcontrol[@localtype = &quot;AcronimoDiSistema&quot;]/term
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="2 > count(control/localcontrol[@localtype = 'AcronimoDiSistema']/term)"/>
      <xs:assert xa:message="[&#x0a;&#x0a;
M004: &lt;ead> non può contenere più di un
      control/localcontrol[@localtype = &quot;IdentificativoDiSistema&quot;]/term
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="2 > count(control/localcontrol[@localtype = 'IdentificativoDiSistema']/term)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M277: Quando &lt;ead> contiene almeno un&#x0a;
      control/filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]/p&#x0a;
      il cui contenuto è pari a &quot;Progetto di digitalizzazione&quot;, l'&lt;archdesc>&#x0a;
      contenuto deve avere @level pari a &quot;otherlevel&quot; e @otherlevel pari&#x0a;
      a &quot;ProgettoDigitalizzazione&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (   control/filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p/text()
                = 'Progetto di digitalizzazione')
            then     archdesc/@level = 'otherlevel'
                 and archdesc/@otherlevel = 'ProgettoDigitalizzazione'
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M278: Quando &lt;ead> contiene almeno un&#x0a;
      control/filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]/p&#x0a;
      ma il contenuto di nessuno di questi è pari&#x0a;
      a &quot;Progetto di digitalizzazione&quot;, l'&lt;archdesc> contenuto deve avere&#x0a;
      @level pari a &quot;otherlevel&quot; e @otherlevel pari a &quot;Progetto&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (   control/filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p
                and not(  control/filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p/text()
                        = 'Progetto di digitalizzazione'))
            then     archdesc/@level = 'otherlevel'
                 and archdesc/@otherlevel = 'Progetto'
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M282: Quando &lt;ead> contiene un &lt;archdesc> con @level pari a &quot;otherlevel&quot;&#x0a;
      e @otherlevel pari a &quot;ProgettoDigitalizzazione&quot;, deve essere presente un&#x0a;
      control/filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]/p&#x0a;
      il cui contenuto è pari a &quot;Progetto di digitalizzazione&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (    (archdesc/@level = 'otherlevel')
                and (archdesc/@otherlevel = 'ProgettoDigitalizzazione'))
            then   control/filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p/text()
                 = 'Progetto di digitalizzazione'
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M283: Quando &lt;ead> contiene un &lt;archdesc> con @level pari a &quot;otherlevel&quot;&#x0a;
      e @otherlevel pari a &quot;Progetto&quot;, devono essere presenti&#x0a;
      control/filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]/p&#x0a;
      il contenuto di nessuno dei quali, però, può essere pari&#x0a;
      a &quot;Progetto di digitalizzazione&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (    (archdesc/@level = 'otherlevel')
                and (archdesc/@otherlevel = 'Progetto'))
            then     control/filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p
                 and not(   control/filedesc/notestmt
                           /controlnote[@localtype = 'TipologiaProgetto']/p/text()
                         = 'Progetto di digitalizzazione')
            else true()"/>
    </xs:complexType>
  </xs:element>
  <!-- control -->
  <xs:complexType name="control">
    <xs:sequence>
      <xs:element name="recordid" type="recordid"/>
      <xs:element name="otherrecordid" type="otherrecordid" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="representation" type="representation" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="filedesc" type="filedesc"/>
      <xs:element name="maintenancestatus" type="maintenancestatus"/>
      <xs:element name="publicationstatus" type="publicationstatus" minOccurs="0"/>
      <xs:element name="maintenanceagency" type="maintenanceagency"/>
      <xs:element name="languagedeclaration" type="languagedeclaration" minOccurs="0"
        maxOccurs="unbounded"/>
      <xs:element name="conventiondeclaration" type="conventiondeclaration" minOccurs="0"
        maxOccurs="unbounded"/>
      <xs:element name="rightsdeclaration" type="rightsdeclaration" minOccurs="0"
        maxOccurs="unbounded"/>
      <xs:element name="localtypedeclaration" type="localtypedeclaration" minOccurs="0"
        maxOccurs="unbounded"/>
      <xs:element name="localcontrol" type="localcontrol" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="maintenancehistory" type="maintenancehistory"/>
      <xs:element name="sources" type="sources" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relatedencoding" type="xs:token"/>
    <xs:attribute name="base" type="xs:anyURI"/>
    <xs:attribute name="langencoding">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="iso639-1"/>
          <xs:enumeration value="iso639-2b"/>
          <xs:enumeration value="iso639-3"/>
          <xs:enumeration value="otherlangencoding"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="scriptencoding">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="iso15924"/>
          <xs:enumeration value="otherscriptencoding"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dateencoding">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="iso8601"/>
          <xs:enumeration value="otherdateencoding"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="countryencoding">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="iso3166-1"/>
          <xs:enumeration value="othercountryencoding"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="repositoryencoding">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="iso15511"/>
          <xs:enumeration value="otherrepositoryencoding"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:assert xa:message="[&#x0a;&#x0a;
M260: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M261: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/titlestmt/subtitle[@localtype = &quot;AcronimoProgetto&quot;]/abbr
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/titlestmt/subtitle[@localtype = 'AcronimoProgetto']/abbr)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M262: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/subtitle[@localtype = &quot;AcronimoProgetto&quot;]/abbr&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/subtitle[@localtype = 'AcronimoProgetto']/abbr)
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M263: Non è ripetibile, in &lt;control>,&#x0a;
      maintenanceagency/agencyname[@localtype = &quot;AgentePrincipale&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(maintenanceagency/agencyname[@localtype = 'AgentePrincipale'])"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M264: In &lt;control>, qualora sia presente un&#x0a;
      maintenanceagency/agencyname[@localtype = &quot;AgentePrincipale&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (maintenanceagency/agencyname[@localtype = 'AgentePrincipale'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M265: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      maintenanceagency/agencyname[@localtype = &quot;AgentePrincipale&quot;]/@id
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then maintenanceagency/agencyname[@localtype = 'AgentePrincipale']/@id
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M266: Non è ripetibile, in &lt;control>, maintenanceagency/descriptivenote/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(maintenanceagency/descriptivenote/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M267: In &lt;control>, qualora sia presente un maintenanceagency/descriptivenote/p&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (maintenanceagency/descriptivenote/p)
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M268: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      deve essere presente anche un maintenanceagency/descriptivenote/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then maintenanceagency/descriptivenote/p
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M269: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      il contenuto di eventuali maintenanceagency/descriptivenote/p devono&#x0a;
      soddisfare il contenuto di una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then every $p in maintenanceagency/descriptivenote/p
                 satisfies $p/text() = ('Responsabile', 'Finanziatore',
                                        'Responsabile scientifico', 'Responsabile operativo',
                                        'Coordinatore', 'Promotore', 'Realizzatore')
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M270: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/author[@localtype = &quot;AgentePartecipante&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/author[@localtype = 'AgentePartecipante'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M274: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M275: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;TipologiaProgetto&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then filedesc/notestmt/controlnote[@localtype = 'TipologiaProgetto']/p
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M279: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;FinalitaProgetto&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'FinalitaProgetto']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M280: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;FinalitaProgetto&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'FinalitaProgetto'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M284: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;ObiettiviProgetto&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'ObiettiviProgetto']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M285: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;ObiettiviProgetto&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'ObiettiviProgetto'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M286: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CriteriSelezioneMateriale&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'CriteriSelezioneMateriale']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M287: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CriteriSelezioneMateriale&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'CriteriSelezioneMateriale'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M288: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CriteriRiproduzioneMateriale&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'CriteriRiproduzioneMateriale']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M289: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CriteriRiproduzioneMateriale&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'CriteriRiproduzioneMateriale'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M290: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CoperturaSpazialeMateriale&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'CoperturaSpazialeMateriale']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M291: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CoperturaSpazialeMateriale&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'CoperturaSpazialeMateriale'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M292: Non è ripetibile, in &lt;control>,&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CoperturaTemporaleMateriale&quot;]/p
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="1 >= count(filedesc/notestmt/controlnote[@localtype = 'CoperturaTemporaleMateriale']/p)"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M293: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/notestmt/controlnote[@localtype = &quot;CoperturaTemporSpazialeale&quot;]&#x0a;
      deve essere presente anche un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/notestmt/controlnote[@localtype = 'CoperturaTemporaleMateriale'])
            then filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M299: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      deve il figlio &lt;maintenancestatus> deve avere @value pari a &quot;derived&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then maintenancestatus[@value = 'derived']
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M300: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      deve essere presente un (e un solo)&#x0a;
      localcontrol[@localtype = &quot;StatusScheda&quot;]/term
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then 1 = count(localcontrol[@localtype = 'StatusScheda']/term)
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M301: In &lt;control>, qualora sia presente un&#x0a;
      filedesc/titlestmt/titleproper[@localtype = &quot;DenominazioneProgetto&quot;]&#x0a;
      il valore di localcontrol[@localtype = &quot;StatusScheda&quot;]/term deve&#x0a;
      soddisfare il contenuto di una precisa lista chiusa di valori ammessi
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (filedesc/titlestmt/titleproper[@localtype = 'DenominazioneProgetto'])
            then every $term in localcontrol[@localtype = 'StatusScheda']/term
                 satisfies $term/text() = ('Bozza', 'In validazione di primo livello',
                                           'Validata (primo livello)',
                                           'In validazione di secondo livello',
                                           'Validata (secondo livello)', 'Pubblicata',
                                           'Copia parallela')
            else true()"/>
  </xs:complexType>
  <xs:complexType name="recordid" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="instanceurl" type="xs:anyURI"/>
  </xs:complexType>
  <xs:complexType name="otherrecordid" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="representation" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attributeGroup ref="am.simplelink"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="filedesc">
    <xs:sequence>
      <xs:element name="titlestmt" type="titlestmt"/>
      <xs:element name="editionstmt" type="editionstmt" minOccurs="0"/>
      <xs:element name="publicationstmt" type="publicationstmt" minOccurs="0"/>
      <xs:element name="seriesstmt" type="seriesstmt" minOccurs="0"/>
      <xs:element name="notestmt" type="notestmt" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="titlestmt">
    <xs:sequence>
      <xs:element name="titleproper" type="titleproper" maxOccurs="unbounded"/>
      <xs:element name="subtitle" type="subtitle" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="author" type="author" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="sponsor" type="sponsor" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="editionstmt">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="edition" type="edition"/>
      <xs:element name="p" type="p"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="publicationstmt">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="publisher" type="publisher"/>
      <xs:element name="date" type="date"/>
      <xs:element name="address" type="address"/>
      <xs:element name="num" type="num"/>
      <xs:element name="p" type="p"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="seriesstmt">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="titleproper" type="titleproper"/>
      <xs:element name="num" type="num"/>
      <xs:element name="p" type="p"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="notestmt">
    <xs:sequence>
      <xs:element name="controlnote" type="controlnote" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="maintenancestatus" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="value" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="revised"/>
          <xs:enumeration value="deleted"/>
          <xs:enumeration value="new"/>
          <xs:enumeration value="deletedsplit"/>
          <xs:enumeration value="deletedmerged"/>
          <xs:enumeration value="deletedreplaced"/>
          <xs:enumeration value="cancelled"/>
          <xs:enumeration value="derived"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="publicationstatus" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="value" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="inprocess"/>
          <xs:enumeration value="approved"/>
          <xs:enumeration value="published"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="languagedeclaration">
    <xs:sequence>
      <xs:element name="language" type="language"/>
      <xs:element name="script" type="script"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="conventiondeclaration">
    <xs:sequence>
      <xs:element name="abbr" type="abbr" minOccurs="0"/>
      <xs:element name="citation" type="citation"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="rightsdeclaration">
    <xs:sequence>
      <xs:element name="abbr" type="abbr" minOccurs="0"/>
      <xs:element name="citation" type="citation"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="localtypedeclaration">
    <xs:sequence>
      <xs:element name="abbr" type="abbr" minOccurs="0"/>
      <xs:element name="citation" type="citation"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="localcontrol">
    <xs:sequence>
      <xs:element name="term" type="term" minOccurs="0"/>
      <xs:choice minOccurs="0">
        <xs:element name="datesingle" type="datesingle"/>
        <xs:element name="daterange" type="daterange"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="term" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="transliteration" type="xs:NMTOKEN"/>
    <xs:attribute name="lastdatetimeverified">
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:date">
              <xs:maxInclusive value="2099-12-31"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYear">
              <xs:maxInclusive value="2099"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYearMonth">
              <xs:maxInclusive value="2099-12"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:dateTime">
              <xs:maxInclusive value="2099-12-31T23:59:59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="am.access.no.normal"/>
  </xs:complexType>
  <xs:complexType name="maintenancehistory">
    <xs:sequence>
      <xs:element name="maintenanceevent" type="maintenanceevent" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="maintenanceevent">
    <xs:sequence>
      <xs:element name="eventtype" type="eventtype"/>
      <xs:element name="eventdatetime" type="eventdatetime"/>
      <xs:element name="agenttype" type="agenttype"/>
      <xs:element name="agent" type="agent"/>
      <xs:element name="eventdescription" type="eventdescription" minOccurs="0"
        maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="eventtype" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="value" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="created"/>
          <xs:enumeration value="revised"/>
          <xs:enumeration value="deleted"/>
          <xs:enumeration value="cancelled"/>
          <xs:enumeration value="derived"/>
          <xs:enumeration value="updated"/>
          <xs:enumeration value="unknown"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="eventdatetime" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="standarddatetime">
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:date">
              <xs:maxInclusive value="2099-12-31"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYear">
              <xs:maxInclusive value="2099"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYearMonth">
              <xs:maxInclusive value="2099-12"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:dateTime">
              <xs:maxInclusive value="2099-12-31T23:59:59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="agenttype" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="value" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="human"/>
          <xs:enumeration value="machine"/>
          <xs:enumeration value="unknown"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="agent" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="eventdescription" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="sources">
    <xs:sequence>
      <xs:element name="source" type="source" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="base" type="xs:anyURI"/>
  </xs:complexType>
  <xs:complexType name="source">
    <xs:sequence>
      <xs:element name="sourceentry" type="sourceentry" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="objectxmlwrap" type="objectxmlwrap" minOccurs="0"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="lastdatetimeverified">
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:date">
              <xs:maxInclusive value="2099-12-31"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYear">
              <xs:maxInclusive value="2099"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYearMonth">
              <xs:maxInclusive value="2099-12"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:dateTime">
              <xs:maxInclusive value="2099-12-31T23:59:59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="am.simplelink"/>
  </xs:complexType>
  <xs:complexType name="sourceentry" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="transliteration" type="xs:NMTOKEN"/>
  </xs:complexType>
  <xs:complexType name="titleproper">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="render">
          <xs:simpleType>
            <xs:restriction base="xs:token">
              <xs:enumeration value="altrender"/>
              <xs:enumeration value="bold"/>
              <xs:enumeration value="bolddoublequote"/>
              <xs:enumeration value="bolditalic"/>
              <xs:enumeration value="boldsinglequote"/>
              <xs:enumeration value="boldsmcaps"/>
              <xs:enumeration value="boldunderline"/>
              <xs:enumeration value="doublequote"/>
              <xs:enumeration value="italic"/>
              <xs:enumeration value="nonproport"/>
              <xs:enumeration value="singlequote"/>
              <xs:enumeration value="smcaps"/>
              <xs:enumeration value="sub"/>
              <xs:enumeration value="super"/>
              <xs:enumeration value="underline"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="subtitle">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="author">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M271: In &lt;author>, quando @localtype vale &quot;AgentePartecipante&quot;, non deve essere&#x0a;
      presente più di un ref/@id
      &#x0a;&#x0a;]"
              xpathDefaultNamespace="##targetNamespace" 
              test="1 >= count(ref/@id)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M272: In &lt;author>, quando @localtype vale &quot;AgentePartecipante&quot;, non deve essere&#x0a;
      presente più di un ref/function[@localtype = &quot;Qualifica&quot;]/part
      &#x0a;&#x0a;]"
              xpathDefaultNamespace="##targetNamespace" 
              test="1 >= count(ref/function[@localtype = 'Qualifica']/part)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M273: In &lt;author>, quando @localtype vale &quot;AgentePartecipante&quot;, il contenuto&#x0a;
      di eventuali ref/function[@localtype = &quot;Qualifica&quot;]/part deve soddisfare&#x0a;
      una precisa lista chiusa di valori ammissibili
      &#x0a;&#x0a;]"
              xpathDefaultNamespace="##targetNamespace" 
              test="every $part in ref/function[@localtype = 'Qualifica']/part
                    satisfies $part/text() = ('Responsabile', 'Finanziatore', 'Partecipante',
                                              'Supporto', 'Responsabile scientifico',
                                              'Responsabile operativo', 'Coordinatore',
                                              'Operatore', 'Promotore', 'Realizzatore')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="sponsor">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="edition">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="publisher">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="controlnote">
    <xs:group maxOccurs="unbounded" ref="m.blocks"/>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M276: In &lt;controlnote>, quando il @localtype vale &quot;TipologiaProgetto&quot;,&#x0a;
      il contenuto di eventuali figli &lt;p> deve soddisfare una precisa lista&#x0a;
      chiusa di valori ammissibili
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (@localtype = 'TipologiaProgetto')
            then every $p in p
                 satisfies $p/text() = ('Progetto di digitalizzazione', 'Censimento/guida',
                                        'Ordinamento', 'Inventariazione',
                                        'Recupero e/o rielaborazione di corredo pregresso',
                                        'Elenco', 'Progetto architettonico')
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M281: In &lt;controlnote>, quando il @localtype vale &quot;FinalitaProgetto&quot;,&#x0a;
      il contenuto di eventuali figli &lt;p> deve soddisfare una precisa lista&#x0a;
      chiusa di valori ammissibili
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (@localtype = 'FinalitaProgetto')
            then every $p in p
                 satisfies $p/text() = ('Riproduzione di serie/fondi archivistici',
                                        'Aggregazione tematica di oggetti archivistici e documentari',
                                        'Mostra documentaria', 'Guida tematica', 'Guida settoriale',
                                        &quot;Guida d'istituto&quot;, 'Guida topografica',
                                        'Ordinamento preliminare', 'Ordinamento virtuale',
                                        'Ordinamento definitivo', 'Inventariazione sommaria',
                                        'Inventariazione analitica',
                                        'Informatizzazione di strumento di ricerca analogico',
                                        'Migrazione di dati',
                                        'Rielaborazione/integrazione di strumento di ricerca pregresso',
                                        'Elenco di consistenza', 'Elenco di versamento',
                                        'Elenco di scarto')
            else true()"/>
  </xs:complexType>
  <xs:complexType name="maintenanceagency">
    <xs:sequence>
      <xs:element name="agencycode" type="agencycode" minOccurs="0"/>
      <xs:element name="otheragencycode" type="otheragencycode" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="agencyname" type="agencyname" maxOccurs="unbounded"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attributeGroup ref="am.countrycode"/>
  </xs:complexType>
  <xs:complexType name="agencycode" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="otheragencycode" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="agencyname" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="citation">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attributeGroup ref="am.simplelink"/>
        <xs:attribute name="lastdatetimeverified">
          <xs:simpleType>
            <xs:union>
              <xs:simpleType>
                <xs:restriction base="xs:date">
                  <xs:maxInclusive value="2099-12-31"/>
                </xs:restriction>
              </xs:simpleType>
              <xs:simpleType>
                <xs:restriction base="xs:gYear">
                  <xs:maxInclusive value="2099"/>
                </xs:restriction>
              </xs:simpleType>
              <xs:simpleType>
                <xs:restriction base="xs:gYearMonth">
                  <xs:maxInclusive value="2099-12"/>
                </xs:restriction>
              </xs:simpleType>
              <xs:simpleType>
                <xs:restriction base="xs:dateTime">
                  <xs:maxInclusive value="2099-12-31T23:59:59"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:union>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- ARCHDESC -->
  <!-- M185: rimossa versione originaria di "archdesc" -->
  <!-- did -->
  <xs:complexType name="did">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:group maxOccurs="unbounded" ref="m.did"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="abstract">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic.plus.access">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="container">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attribute name="parent" type="xs:IDREFS"/>
        <xs:attribute name="containerid" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="dao">
    <xs:sequence>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attributeGroup ref="am.simplelink"/>
    <xs:attribute name="identifier" type="xs:token"/>
    <xs:attribute name="xpointer" type="xs:token"/>
    <xs:attribute name="entityref" type="xs:ENTITY"/>
    <xs:attribute name="daotype" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="borndigital"/>
          <xs:enumeration value="derived"/>
          <xs:enumeration value="unknown"/>
          <xs:enumeration value="otherdaotype"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="otherdaotype" type="xs:token"/>
    <xs:attribute name="coverage">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="whole"/>
          <xs:enumeration value="part"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="daoset">
    <xs:sequence>
      <xs:element name="dao" type="dao"/>
      <xs:element name="dao" type="dao" maxOccurs="unbounded"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="coverage">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="whole"/>
          <xs:enumeration value="part"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="base" type="xs:anyURI"/>
  </xs:complexType>
  <xs:complexType name="didnote">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="langmaterial">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="language" type="language"/>
        <xs:element name="languageset" type="languageset"/>
      </xs:choice>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="materialspec">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attribute name="localtype" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="physdescset">
    <xs:sequence>
      <xs:element name="physdescstructured" type="physdescstructured"/>
      <xs:element name="physdescstructured" type="physdescstructured" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="parallel" type="av.boolean"/>
    <xs:attribute name="coverage">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="whole"/>
          <xs:enumeration value="part"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="physdesc">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="physloc">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attribute name="parent" type="xs:IDREFS"/>
        <!-- test annullato
        <xs:assert xa:message="[&#x0a;&#x0a;
M037: In &lt;physloc> deve essere presente almeno un figlio &lt;ptr> con gli&#x0a;
      attributi @target e @linkrole, il secondo dei quali deve valere &quot;Internal&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="ptr[@linkrole = 'Internal']/@id"/>
          -->
        <!-- test annullato
        <xs:assert xa:message="[&#x0a;&#x0a;
M038: In &lt;physloc> deve essere presente almeno un figlio &lt;ref> con @arcrole&#x0a;
      pari a &quot;DaPezzo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="ref[@arcrole = 'DaPezzo']"/>
          -->
        <!-- test annullato
        <xs:assert xa:message="[&#x0a;&#x0a;
M039: In &lt;physloc> deve essere presente almeno un figlio &lt;ref> con @arcrole&#x0a;
      pari a &quot;APezzo&quot;
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="ref[@arcrole = 'APezzo']"/>
          -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="origination">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="corpname" type="corpname"/>
      <xs:element name="famname" type="famname"/>
      <xs:element name="name" type="name"/>
      <xs:element name="persname" type="persname"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="physdescstructured">
    <xs:sequence>
      <xs:element name="quantity" type="quantity"/>
      <xs:element name="unittype" type="unittype"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="physfacet" type="physfacet"/>
        <xs:element name="dimensions" type="dimensions"/>
      </xs:choice>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="physdescstructuredtype" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="carrier"/>
          <xs:enumeration value="materialtype"/>
          <xs:enumeration value="spaceoccupied"/>
          <xs:enumeration value="otherphysdescstructuredtype"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="otherphysdescstructuredtype" type="xs:token"/>
    <xs:attributeGroup ref="a.coverage"/>
  </xs:complexType>
  <xs:complexType name="quantity" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="approximate" type="av.boolean"/>
  </xs:complexType>
  <xs:complexType name="unittype" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attributeGroup ref="am.access.no.normal"/>
  </xs:complexType>
  <xs:complexType name="repository">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="corpname" type="corpname"/>
        <xs:element name="famname" type="famname"/>
        <xs:element name="name" type="name"/>
        <xs:element name="persname" type="persname"/>
      </xs:choice>
      <xs:element name="address" type="address" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="unitdate">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attributeGroup ref="a.unitdatetype"/>
        <xs:attribute name="datechar" type="xs:token"/>
        <xs:attribute name="certainty" type="xs:NMTOKEN"/>
        <xs:attributeGroup ref="am.dates.era"/>
        <xs:attributeGroup ref="am.dates.calendar"/>
        <xs:attributeGroup ref="am.date.normal"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="unitdatestructured">
    <xs:choice>
      <xs:element name="datesingle" type="datesingle"/>
      <xs:element name="daterange" type="daterange"/>
      <xs:element name="dateset" type="dateset"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attributeGroup ref="a.unitdatetype"/>
    <xs:attribute name="datechar" type="xs:token"/>
    <xs:attribute name="certainty" type="xs:NMTOKEN"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attributeGroup ref="am.dates.era"/>
    <xs:attributeGroup ref="am.dates.calendar"/>
  </xs:complexType>
  <xs:complexType name="unittitle">
    <xs:complexContent>
      <!-- rimosso M010 per ristrutturazione della gestione
           delle date
      <xs:extension base="m.mixed.basic.plus.access.unittitle">
      -->
      <xs:extension base="m.mixed.basic.plus.access">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="normal" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="unitid">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="label" type="xs:string"/>
        <xs:attributeGroup ref="am.countrycode"/>
        <xs:attribute name="repositorycode" type="xs:token"/>
        <xs:attribute name="identifier"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M005: se &lt;unitid> ha @localtype pari a &quot;AltroId&quot;, allora deve anche avere&#x0a;
      @label
      &#x0a;&#x0a;]"
        test="if (@localtype = 'AltroId') then @label else true()"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- archdesc notes -->
  <xs:complexType name="accessrestrict">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="accessrestrict" type="accessrestrict"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="accruals">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="accruals" type="accruals"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="acqinfo">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="acqinfo" type="acqinfo"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="altformavail">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="altformavail" type="altformavail"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="appraisal">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="appraisal" type="appraisal"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="arrangement">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="arrangement" type="arrangement"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <!-- M032: abolito in seguito alle recenti modifiche alla mappatura
    <xs:assert xa:message="[&#x0a;&#x0a;
M032: Qualora in &lt;arrangement> sia presente un figlio &lt;head> con contenuto pari&#x0a;
      a &quot;numerazione&quot;, allora il @localtype deve valere &quot;Numerazione&quot; e deve&#x0a;
      essere presente anche un p/num[@localtype = &quot;TipoNumerazione&quot;] il cui&#x0a;
      contenuto soddisfi una precisa lista chiusa di valori ammessi
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (head[text() = 'numerazione'])
            then     (@localtype = 'Numerazione')
                 and (  p/num[@localtype='TipoNumerazione']/text()
                      = ('alfabetico', 'numeri arabi', 'numeri romani'))
            else true()"/>
            -->
    <xs:assert xa:message="[&#x0a;&#x0a;
M306: Qualora in un &lt;arrangement>, con @localtype pari a &quot;Numerazione&quot;,&#x0a;
      i valori degli eventuali p/num/@localtype devono soddisfare una precisa&#x0a;
      lista chiusa di valori ammessi
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (@localtype = 'Numerazione')
            then every $type in p/num/@localtype
                 satisfies $type = ('Alfabetico', 'Numeri arabi', 'numeri romani')
            else true()"/>
  </xs:complexType>
  <xs:complexType name="bibliography">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <!-- <xs:element name="bibliography" type="bibliography"/> -->
        <!-- M186: specializzazione "bibliography" per gestione tracciati -->
        <xs:element name="bibliography">
          <xs:alternative type="bibliography.fntn" test="@localtype = 'FonteNormativa'"/>
          <xs:alternative type="bibliography.rifb" test="@localtype = 'RiferimentoBibliografico'"/>
          <xs:alternative type="bibliography.rifw" test="@localtype = 'RiferimentoWeb'"/>
          <xs:alternative type="bibliography"/>
        </xs:element>
        <!-- M231: utilizzata la specializzazione "archref.bibl",
                   di "archref", quando "archref" e' figlio
                   di "bibliography", ad eccezione di quando
                   @altrender e' pari a "LinkFonteArchivistica",
                   quando si usa la versione base -->
        <xs:element name="archref">
          <xs:alternative type="archref"      test="@altrender = 'LinkFonteArchivistica'"/>
          <xs:alternative type="archref.bibl"/>
        </xs:element>
        <xs:element name="bibref" type="bibref"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="bioghist">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="bioghist" type="bioghist"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="controlaccess">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:group ref="m.access"/>
        <xs:element name="controlaccess" type="controlaccess"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="custodhist">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="custodhist" type="custodhist"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="fileplan">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="fileplan" type="fileplan"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="index">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.blocks"/>
      <xs:choice>
        <xs:sequence>
          <xs:element name="listhead" type="listhead" minOccurs="0"/>
          <xs:element name="indexentry" type="indexentry" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:element name="index" type="index" maxOccurs="unbounded"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="indexentry">
    <xs:sequence>
      <xs:choice>
        <xs:element name="namegrp" type="namegrp"/>
        <xs:group ref="m.access"/>
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ptrgrp" type="ptrgrp"/>
        <xs:group ref="m.refs"/>
      </xs:choice>
      <xs:element name="indexentry" type="indexentry" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="namegrp">
    <xs:group maxOccurs="unbounded" ref="m.access"/>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="ptrgrp">
    <xs:group maxOccurs="unbounded" ref="m.refs"/>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="legalstatus">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="legalstatus" type="legalstatus"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="odd">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="odd" type="odd"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M257: In &lt;odd>, quando @localtype non è pari a &quot;Osservazioni&quot;, deve essere&#x0a;
      presente almeno un figlio &lt;p>
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (not(@localtype) or (@localtype != 'Osservazioni'))
            then p
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M258: In &lt;odd>, quando @localtype è pari a &quot;Osservazioni&quot;, non deve essere&#x0a;
      presente nessun figlio &lt;p>
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (@localtype = 'Osservazioni')
            then not(p)
            else true()"/>
  </xs:complexType>
  <xs:complexType name="originalsloc">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="originalsloc" type="originalsloc"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="otherfindaid">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="otherfindaid" type="otherfindaid"/>
        <xs:element name="archref" type="archref"/>
        <xs:element name="bibref" type="bibref"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="phystech">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="phystech" type="phystech"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="prefercite">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="prefercite" type="prefercite"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="processinfo">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <!-- M219: uso della specializzazione "processinfo.comp" nel caso
                   dei tracciati -->
        <xs:element name="processinfo">
          <xs:alternative type="processinfo.comp" test="@localtype = 'ComplessoArchivistico'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'UnitaArchivistica'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'UnitaDocumentale'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'FonteArchivistica'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'FonteNormativa'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'Progetto'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'RiferimentoBibliografico'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'RiferimentoWeb'"/>
          <xs:alternative type="processinfo.comp" test="@localtype = 'Tematismo'"/>
          <xs:alternative type="processinfo"/>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="relatedmaterial">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="relatedmaterial" type="relatedmaterial"/>
        <xs:element name="archref" type="archref"/>
        <xs:element name="bibref" type="bibref"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="scopecontent">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="scopecontent" type="scopecontent"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="separatedmaterial">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="separatedmaterial" type="separatedmaterial"/>
        <xs:element name="archref" type="archref"/>
        <xs:element name="bibref" type="bibref"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="userestrict">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice maxOccurs="unbounded">
        <xs:group ref="m.blocks"/>
        <xs:element name="userestrict" type="userestrict"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <!-- controlaccess elements -->
  <xs:complexType name="corpname">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="famname">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="function">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="genreform">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="geogname">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
      <xs:element name="geographiccoordinates" type="geographiccoordinates" minOccurs="0"
        maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="geographiccoordinates" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="coordinatesystem" use="required" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="name">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="occupation">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="persname">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="subject">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="title">
    <xs:sequence>
      <xs:element name="part" type="part" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attributeGroup ref="am.access"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relator" type="xs:token"/>
    <xs:attribute name="render">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="altrender"/>
          <xs:enumeration value="bold"/>
          <xs:enumeration value="bolddoublequote"/>
          <xs:enumeration value="bolditalic"/>
          <xs:enumeration value="boldsinglequote"/>
          <xs:enumeration value="boldsmcaps"/>
          <xs:enumeration value="boldunderline"/>
          <xs:enumeration value="doublequote"/>
          <xs:enumeration value="italic"/>
          <xs:enumeration value="nonproport"/>
          <xs:enumeration value="singlequote"/>
          <xs:enumeration value="smcaps"/>
          <xs:enumeration value="sub"/>
          <xs:enumeration value="super"/>
          <xs:enumeration value="underline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="part">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic.date">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attributeGroup ref="am.access.no.normal"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- BLOCKS -->
  <!-- p -->
  <xs:complexType name="p">
    <xs:complexContent>
      <xs:extension base="m.para.content">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- blockquote -->
  <xs:complexType name="blockquote">
    <xs:choice maxOccurs="unbounded">
      <xs:group ref="m.inter.noquote"/>
      <xs:element name="p" type="p"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <!-- chronlist -->
  <xs:complexType name="chronlist">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:element name="listhead" type="listhead" minOccurs="0"/>
      <xs:element name="chronitem" type="chronitem" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="chronitem">
    <xs:sequence>
      <xs:choice>
        <xs:element name="datesingle" type="datesingle"/>
        <xs:element name="daterange" type="daterange"/>
        <xs:element name="dateset" type="dateset"/>
      </xs:choice>
      <xs:choice>
        <xs:sequence>
          <xs:element name="geogname" type="geogname" minOccurs="0"/>
          <xs:element name="event" type="event"/>
        </xs:sequence>
        <xs:element name="chronitemset" type="chronitemset" maxOccurs="unbounded"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="chronitemset">
    <xs:sequence>
      <xs:element name="geogname" type="geogname" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="event" type="event" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="event">
    <xs:complexContent>
      <xs:extension base="m.para.content">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- list -->
  <xs:complexType name="list">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:choice>
        <xs:element name="item" type="item" maxOccurs="unbounded"/>
        <xs:sequence>
          <xs:element name="listhead" type="listhead" minOccurs="0"/>
          <xs:element name="defitem" type="defitem" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="listtype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="deflist"/>
          <xs:enumeration value="unordered"/>
          <xs:enumeration value="ordered"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mark">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="disc"/>
          <xs:enumeration value="circle"/>
          <xs:enumeration value="square"/>
          <xs:enumeration value="none"/>
          <xs:enumeration value="inherit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="numeration">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="decimal"/>
          <xs:enumeration value="decimal-leading-zero"/>
          <xs:enumeration value="lower-roman"/>
          <xs:enumeration value="upper-roman"/>
          <xs:enumeration value="lower-greek"/>
          <xs:enumeration value="lower-latin"/>
          <xs:enumeration value="upper-latin"/>
          <xs:enumeration value="armenian"/>
          <xs:enumeration value="georgian"/>
          <xs:enumeration value="lower-alpha"/>
          <xs:enumeration value="upper-alpha"/>
          <xs:enumeration value="inherit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="defitem">
    <xs:sequence>
      <xs:element name="label" type="label"/>
      <xs:element name="item" type="item"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="label">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="item">
    <xs:complexContent>
      <xs:extension base="m.para.content">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="listhead">
    <xs:sequence>
      <xs:element name="head01" type="head01" minOccurs="0"/>
      <xs:element name="head02" type="head02" minOccurs="0"/>
      <xs:element name="head03" type="head03" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="head01">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="head02">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="head03">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- table -->
  <xs:complexType name="table">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:element name="tgroup" type="tgroup" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="frame">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="bottom"/>
          <xs:enumeration value="topbot"/>
          <xs:enumeration value="all"/>
          <xs:enumeration value="sides"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="colsep" type="av.boolean"/>
    <xs:attribute name="rowsep" type="av.boolean"/>
    <xs:attribute name="pgwide" type="av.boolean"/>
  </xs:complexType>
  <xs:complexType name="tgroup">
    <xs:sequence>
      <xs:element name="colspec" type="colspec" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="thead" type="thead" minOccurs="0"/>
      <xs:element name="tbody" type="tbody"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="cols" use="required" type="xs:NMTOKEN"/>
    <xs:attribute name="colsep" type="av.boolean"/>
    <xs:attribute name="rowsep" type="av.boolean"/>
    <xs:attribute name="align">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="justify"/>
          <xs:enumeration value="char"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="colspec">
    <xs:attribute name="colnum" type="xs:NMTOKEN"/>
    <xs:attribute name="colname" type="xs:NMTOKEN"/>
    <xs:attribute name="colwidth" type="xs:token"/>
    <xs:attribute name="colsep" type="av.boolean"/>
    <xs:attribute name="rowsep" type="av.boolean"/>
    <xs:attribute name="align">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="justify"/>
          <xs:enumeration value="char"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="char" type="xs:token"/>
    <xs:attribute name="charoff" type="xs:NMTOKEN"/>
  </xs:complexType>
  <xs:complexType name="tbody">
    <xs:sequence>
      <xs:element name="row" type="row" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="valign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="middle"/>
          <xs:enumeration value="bottom"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="row">
    <xs:sequence>
      <xs:element name="entry" type="entry" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="rowsep" type="av.boolean"/>
    <xs:attribute name="valign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="middle"/>
          <xs:enumeration value="bottom"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="entry">
    <xs:complexContent>
      <xs:extension base="m.para.content">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="colname" type="xs:NMTOKEN"/>
        <xs:attribute name="namest" type="xs:NMTOKEN"/>
        <xs:attribute name="nameend" type="xs:NMTOKEN"/>
        <xs:attribute name="morerows" type="xs:NMTOKEN"/>
        <xs:attribute name="colsep" type="av.boolean"/>
        <xs:attribute name="rowsep" type="av.boolean"/>
        <xs:attribute name="align">
          <xs:simpleType>
            <xs:restriction base="xs:token">
              <xs:enumeration value="left"/>
              <xs:enumeration value="right"/>
              <xs:enumeration value="center"/>
              <xs:enumeration value="justify"/>
              <xs:enumeration value="char"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="char" type="xs:token"/>
        <xs:attribute name="charoff" type="xs:NMTOKEN"/>
        <xs:attribute name="valign">
          <xs:simpleType>
            <xs:restriction base="xs:token">
              <xs:enumeration value="top"/>
              <xs:enumeration value="middle"/>
              <xs:enumeration value="bottom"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="thead">
    <xs:sequence>
      <xs:element name="row" type="row" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="valign">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="middle"/>
          <xs:enumeration value="bottom"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <!-- language blocks -->
  <xs:complexType name="language" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="langcode" type="xs:NMTOKEN"/>
  </xs:complexType>
  <xs:complexType name="languageset">
    <xs:sequence>
      <xs:element name="language" type="language" maxOccurs="unbounded"/>
      <xs:element name="script" type="script" maxOccurs="unbounded"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="script" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="scriptcode" type="xs:NMTOKEN"/>
  </xs:complexType>
  <!-- physdescstructured blocks -->
  <xs:complexType name="dimensions" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="m.mixed.basic.elements"/>
      <xs:element name="dimensions" type="dimensions"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="unit" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="physfacet">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic.plus.access">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
        <xs:attributeGroup ref="am.access.no.normal"/>
        <xs:attribute name="localtype" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- other blocks -->
  <xs:complexType name="address">
    <xs:sequence>
      <xs:element name="addressline" type="addressline" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
  </xs:complexType>
  <xs:complexType name="addressline">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="archref">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic.plus.access">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="bibref">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic.plus.access">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="descriptivenote">
    <xs:sequence>
      <xs:element name="p" type="p" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="footnote">
    <xs:group maxOccurs="unbounded" ref="m.blocks"/>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="show">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="new"/>
          <xs:enumeration value="replace"/>
          <xs:enumeration value="embed"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="actuate">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="onload"/>
          <xs:enumeration value="onrequest"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="head">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="althead" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- DATES -->
  <xs:complexType name="datesingle">
    <xs:complexContent>
      <xs:extension base="m.datesingle">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M176: In &lt;datesingle>, quando @localtype non è pari a &quot;DataSingola&quot;, non deve&#x0a;
      essere presente @notbefore
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="(@localtype = 'DataSingola') or not(@notbefore)"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M177: In &lt;datesingle>, quando @localtype non è pari a &quot;DataSingola&quot;, non deve&#x0a;
      essere presente @notafter
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="(@localtype = 'DataSingola') or not(@notafter)"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- M162: creata specializzazione, di "datesingle" da utilizzare in
             "dateset" quando @localhost pari a "DataTestuale" -->
  <xs:complexType name="datesingle.dataTestuale">
    <xs:complexContent>
      <xs:extension base="datesingle">
        <xs:assert xa:message="[&#x0a;&#x0a;
M165: In &lt;datesingle>, quando @localtype è pari a &quot;DataTestuale&quot;, il contenuto&#x0a;
      non può essere vuoto
      &#x0a;&#x0a;]"
          test="text() != ''"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M166: In &lt;datesingle>, quando @localtype è pari a &quot;DataTestuale&quot;, deve essere&#x0a;
      presente @altrender e il suo valore deve soddisfare una precisa lista di&#x0a;
      valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="@altrender != ('Intervallo di date', 'Data singola', 'Data aperta (a partire da)',
                               'Data aperta (fino a)', 'Data non rilevata/non rilevabile')"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- M163: creata specializzazione, di "datesingle" da utilizzare in
             "dateset" quando @localhost pari a "DataSingola" -->
  <xs:complexType name="datesingle.dataSingola">
    <xs:complexContent>
      <xs:extension base="datesingle">
        <!-- controllo abolito poiche' errato
        <xs:assert xa:message="[&#x0a;&#x0a;
M167: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, il contenuto&#x0a;
      non può essere vuoto
      &#x0a;&#x0a;]"
          test="text() != ''"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M168: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, se è&#x0a;
      presente @altrender il suo valore deve soddisfare una precisa lista di&#x0a;
      valori ammissibili
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="   not(@altrender)
                or (@altrender != ('Data approssimativa', 'Data attribuita', 'Data incerta',
                                   'Data incerta e attribuita'))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M080: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, il valore di&#x0a;
      @notbefore, se presente, deve corrispondere a un numero, positivo, di&#x0a;
      quattro cifre corrispondente a un anno; i valori precedenti all'anno 1000&#x0a;
      richiedono degli zeri sulla sinistra (esempio: l'anno 37 a.C. deve essere&#x0a;
      rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notbefore) or matches(@notbefore, '^[0-9]{4}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M081: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, il valore di&#x0a;
      @notafter, se presente, deve corrispondere a un numero, positivo, di&#x0a;
      quattro cifre corrispondente a un anno; i valori precedenti all'anno 1000&#x0a;
      richiedono degli zeri sulla sinistra (esempio: l'anno 37 a.C. deve essere&#x0a;
      rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notafter) or matches(@notafter, '^[0-9]{4}$')"/>
        <!-- controllo abolito poiche' assorbito da M307
        <xs:assert xa:message="[&#x0a;&#x0a;
M082: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, devono&#x0a;
      essere presenti sia @notbefore che @notafter oppure, in alternativa,&#x0a;
      nessuno dei due
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="1 != (count(@notbefore) + count(@notafter))"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M083: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, se @notbefore&#x0a;
      e @notafter sono entrambi presenti, i loro valori devono soddisfare&#x0a;
      alcune precise regole
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="if (@notbefore)
                then    (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (46 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (91 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (26 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (76 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M174: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, il valore di&#x0a;
      @notbefore, se presente, non può valere &quot;0000&quot; (valore non&#x0a;
      accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notbefore) or (@notbefore != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M175: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, il valore di&#x0a;
      @notafter, se presente, non può valere &quot;0000&quot; (valore non&#x0a;
      accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notafter) or (@notafter != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M307: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, deve essere&#x0a;
      non vuoto il contenuto dell'elemento oppure, in alternativa, presenti e&#x0a;
      con contenuto non nullo entrambi gli attributi @notafter e @notbefore;&#x0a;
      non è consentito che siano vere entrambe le cose
      &#x0a;&#x0a;]"
          test="   ((text() != '') and not(@notbefore) and not(@notafter))
                or (not(text()) and (@notbefore != '') and (@notafter != ''))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M308: In &lt;datesingle>, quando @localtype è pari a &quot;DataSingola&quot;, deve essere&#x0a;
      presente, con valore non nullo, l'attributo @standarddate
      &#x0a;&#x0a;]"
          test="@standarddate != ''"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- M164: creata specializzazione, di "datesingle" da utilizzare in
             "dateset" quando @localhost pari a "NoteAllaDatazione" -->
  <xs:complexType name="datesingle.noteAllaDatazione">
    <xs:complexContent>
      <xs:extension base="datesingle">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="daterange">
    <xs:sequence>
      <xs:element name="fromdate" type="fromdate" minOccurs="0"/>
      <xs:element name="todate" type="todate" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M019: È obbligatoria, in &lt;daterange>, la presenza di almeno un figlio&#x0a;
      &lt;fromdate> o di un figlio &lt;todate>
      &#x0a;&#x0a;]"
        xpathDefaultNamespace="##targetNamespace" 
        test="fromdate or todate"/>
  </xs:complexType>
  <xs:complexType name="fromdate">
    <xs:complexContent>
      <xs:extension base="m.datesingle">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M014: In &lt;fromdate> non deve essere presente @altrender oppure, se presente, il&#x0a;
      suo contenuto deve soddisfare una lista chiusa di valori ammessi
      &#x0a;&#x0a;]"
          test="   not(@altrender)
                or (@altrender = ('Data approssimativa', 'Data attribuita', 'Data incerta',
                                  'Data post quem', 'Data incerta e attribuita'))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M080: In &lt;fromdate> il valore di @notbefore, se presente, deve corrispondere a&#x0a;
      un numero, positivo, di quattro cifre corrispondente a un anno; i valori&#x0a;
      precedenti all'anno 1000 richiedono degli zeri sulla sinistra (esempio:&#x0a;
      l'anno 37 a.C. deve essere rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          test="not(@notbefore) or matches(@notbefore, '^[0-9]{4}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M081: In &lt;fromdate> il valore di @notafter, se presente, deve corrispondere a&#x0a;
      un numero, positivo, di quattro cifre corrispondente a un anno; i valori&#x0a;
      precedenti all'anno 1000 richiedono degli zeri sulla sinistra (esempio:&#x0a;
      l'anno 37 a.C. deve essere rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          test="not(@notafter) or matches(@notafter, '^[0-9]{4}$')"/>
        <!-- controllo annullato poiche' assorbito da M307
        <xs:assert xa:message="[&#x0a;&#x0a;
M082: In &lt;fromdate>, @notbefore e @notafter devono essere o entrambi&#x0a;
      presenti o entrambi assenti
      &#x0a;&#x0a;]"
          test="1 != (count(@notbefore) + count(@notafter))"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M083: In &lt;fromdate>, se @notbefore e @notafter sono entrambi presenti, i loro&#x0a;
      valori devono soddisfare alcune precise regole
      &#x0a;&#x0a;]"
          test="if (@notbefore)
                then    (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (46 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (91 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (26 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (76 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M174: In &lt;fromdate> il valore di @notbefore, se presente, non può valere &quot;0000&quot;&#x0a;
      (valore non accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notbefore) or (@notbefore != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M175: In &lt;fromdate> il valore di @notafter, se presente, non può valere &quot;0000&quot;&#x0a;
      (valore non accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notafter) or (@notafter != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M307: In &lt;fromdate> deve essere non vuoto il contenuto dell'elemento oppure,&#x0a;
      in alternativa, presenti e con contenuto non nullo entrambi gli attributi&#x0a;
      @notafter e @notbefore; non è consentito che siano vere entrambe le cose
      &#x0a;&#x0a;]"
          test="   ((text() != '') and not(@notbefore) and not(@notafter))
                or (not(text()) and (@notbefore != '') and (@notafter != ''))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M308: In &lt;fromdate> deve essere presente, con valore non nullo,&#x0a;
      l'attributo @standarddate
      &#x0a;&#x0a;]"
          test="@standarddate != ''"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="todate">
    <xs:complexContent>
      <xs:extension base="m.datesingle">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M015: In &lt;todate> non deve essere presente @altrender oppure, se presente, il&#x0a;
      suo contenuto deve soddisfare una lista chiusa di valori ammessi
      &#x0a;&#x0a;]"
          test="   not(@altrender)
                or (@altrender = ('Data ante quem', 'Data approssimativa', 'Data attribuita',
                                  'Data incerta', 'DataIncerta e attribuita'))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M080: In &lt;todate> il valore di @notbefore, se presente, deve corrispondere a un&#x0a;
      numero, positivo, di quattro cifre corrispondente a un anno; i valori&#x0a;
      precedenti all'anno 1000 richiedono degli zeri sulla sinistra (esempio:&#x0a;
      l'anno 37 a.C. deve essere rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          test="not(@notbefore) or matches(@notbefore, '^[0-9]{4}$')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M081: In &lt;todate> il valore di @notafter, se presente, deve corrispondere a un&#x0a;
      numero, positivo, di quattro cifre corrispondente a un anno; i valori&#x0a;
      precedenti all'anno 1000 richiedono degli zeri sulla sinistra (esempio:&#x0a;
      l'anno 37 a.C. deve essere rappresentato come &quot;0037&quot;)
      &#x0a;&#x0a;]"
          test="not(@notafter) or matches(@notafter, '^[0-9]{4}$')"/>
        <!-- controllo annullato poiche' assorbito da M307
        <xs:assert xa:message="[&#x0a;&#x0a;
M082: In &lt;todate>, @notbefore e @notafter devono essere o entrambi presenti&#x0a;
      o entrambi assenti
      &#x0a;&#x0a;]"
          test="1 != (count(@notbefore) + count(@notafter))"/>
          -->
        <xs:assert xa:message="[&#x0a;&#x0a;
M083: In &lt;todate>, se @notbefore e @notafter sono entrambi presenti, i loro&#x0a;
      valori devono soddisfare alcune precise regole
      &#x0a;&#x0a;]"
          test="if (@notbefore)
                then    (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (46 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    (91 = (number(@notbefore) mod 100))
                         and (number(@notafter) =  9 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (26 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    (76 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 24 + number(@notbefore)))
                     or (    ( 1 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                     or (    (51 = (number(@notbefore) mod 100))
                         and (number(@notafter) = 49 + number(@notbefore)))
                else true()"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M174: In &lt;todate> il valore di @notbefore, se presente, non può valere &quot;0000&quot;&#x0a;
      (valore non accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notbefore) or (@notbefore != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M175: In &lt;todate> il valore di @notafter, se presente, non può valere &quot;0000&quot;&#x0a;
      (valore non accettabile per un attributo che indica un anno)
      &#x0a;&#x0a;]"
          xpathDefaultNamespace="##targetNamespace" 
          test="not(@notafter) or (@notafter != '0000')"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M307: In &lt;todate> deve essere non vuoto il contenuto dell'elemento oppure,&#x0a;
      in alternativa, presenti e con contenuto non nullo entrambi gli attributi&#x0a;
      @notafter e @notbefore; non è consentito che siano vere entrambe le cose
      &#x0a;&#x0a;]"
          test="   ((text() != '') and not(@notbefore) and not(@notafter))
                or (not(text()) and (@notbefore != '') and (@notafter != ''))"/>
        <xs:assert xa:message="[&#x0a;&#x0a;
M308: In &lt;fromdate> deve essere presente, con valore non nullo,&#x0a;
      l'attributo @standarddate
      &#x0a;&#x0a;]"
          test="@standarddate != ''"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="dateset">
    <xs:sequence>
      <xs:choice minOccurs="2" maxOccurs="unbounded">
        <!-- M162: introdotta specializzazione di "datesingle" per quando
                   @localtype e' pari a "DataTestuale" -->
        <!-- M163: introdotta specializzazione di "datesingle" per quando
                   @localtype e' pari a "DataSingola" -->
        <!-- M164: introdotta specializzazione di "datesingle" per quando
                   @localtype e' pari a "NoteAllaDatazione" -->
        <xs:element name="datesingle">
          <xs:alternative type="datesingle.dataTestuale"      test="@localtype = 'DataTestuale'"/>
          <xs:alternative type="datesingle.dataSingola"       test="@localtype = 'DataSingola'"/>
          <xs:alternative type="datesingle.noteAllaDatazione" test="@localtype = 'NoteAllaDatazione'"/>
          <xs:alternative type="datesingle"/>
        </xs:element>
        <xs:element name="daterange" type="daterange"/>
      </xs:choice>
      <!--
      <xs:choice>
        <xs:element name="datesingle" type="datesingle"/>
        <xs:element name="daterange" type="daterange"/>
      </xs:choice>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="datesingle" type="datesingle"/>
        <xs:element name="daterange" type="daterange"/>
      </xs:choice>
      -->
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M169: In &lt;dateset>, quando contiene un &lt;datesingle> con @localtype pari a&#x0a;
      &quot;DataTestuale&quot; e @altrender pari a &quot;Data singola&quot;, deve contenere&#x0a;
      anche un &lt;datesingle> con @localtype pari a &quot;DataSingola&quot; e non deve&#x0a;
      contenere un &lt;daterange>
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (datesingle[    (@localtype = 'DataTestuale')
                           and (@altrender = 'Data singola')])
            then     datesingle[@localtype = 'DataSingola']
                 and not(daterange)
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M170: In &lt;dateset>, quando contiene un &lt;datesingle> con @localtype pari a&#x0a;
      &quot;DataTestuale&quot; e @altrender pari a &quot;Intervallo di date&quot;, deve contenere&#x0a;
      anche un unico &lt;daterange>, sia con &lt;fromdate> che con &lt;todate>, e non&#x0a;
      deve contenere un &lt;datesingle> con @localtype pari a &quot;DataSingola&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (datesingle[    (@localtype = 'DataTestuale')
                           and (@altrender = 'Intervallo di date')])
            then     not(datesingle[@localtype = 'DataSingola'])
                 and 1 = count(daterange)
                 and daterange[fromdate and todate]
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M171: In &lt;dateset>, quando contiene un &lt;datesingle> con @localtype pari a&#x0a;
      &quot;DataTestuale&quot; e @altrender pari a &quot;Data aperta (a partire da)&quot;, deve&#x0a;
      contenere un unico &lt;daterange>, con &lt;fromdate> ma senza &lt;todate>, e non&#x0a;
      deve contenere un &lt;datesingle> con @localtype pari a &quot;DataSingola&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (datesingle[    (@localtype = 'DataTestuale')
                           and (@altrender = 'Data aperta (a partire da)')])
            then     not(datesingle[@localtype = 'DataSingola'])
                 and 1 = count(daterange)
                 and daterange[fromdate and not(todate)]
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M172: In &lt;dateset>, quando contiene un &lt;datesingle> con @localtype pari a&#x0a;
      &quot;DataTestuale&quot; e @altrender pari a &quot;Data aperta (fino a)&quot;, deve&#x0a;
      contenere un unico &lt;daterange>, senza &lt;fromdate> ma con &lt;todate>, e non&#x0a;
      deve contenere un &lt;datesingle> con @localtype pari a &quot;DataSingola&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (datesingle[    (@localtype = 'DataTestuale')
                           and (@altrender = 'Data aperta (fino a)')])
            then     not(datesingle[@localtype = 'DataSingola'])
                 and 1 = count(daterange)
                 and daterange[not(fromdate) and todate]
            else true()"/>
    <xs:assert xa:message="[&#x0a;&#x0a;
M173: In &lt;dateset>, quando contiene un &lt;datesingle> con @localtype pari a&#x0a;
      &quot;DataTestuale&quot; e @altrender pari a &quot;Data non rilevata/non rilevabile&quot;,&#x0a;
      non deve contenere né &lt;daterange> né un &lt;datesingle> con @localtype pari&#x0a;
      a &quot;DataSingola&quot;
      &#x0a;&#x0a;]"
      xpathDefaultNamespace="##targetNamespace" 
      test="if (datesingle[    (@localtype = 'DataTestuale')
                           and (@altrender = 'Data non rilevata/non rilevabile')])
            then     not(datesingle[@localtype = 'DataSingola'])
                 and not(daterange)
            else true()"/>
  </xs:complexType>
  <!-- MIXED CONTENT -->
  <xs:complexType name="abbr" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="expan" type="xs:string"/>
  </xs:complexType>
  <xs:complexType name="date">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attributeGroup ref="am.dates.era"/>
        <xs:attributeGroup ref="am.dates.calendar"/>
        <xs:attributeGroup ref="am.date.normal"/>
        <xs:attribute name="certainty" type="xs:NMTOKEN"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="emph">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="render">
          <xs:simpleType>
            <xs:restriction base="xs:token">
              <xs:enumeration value="altrender"/>
              <xs:enumeration value="bold"/>
              <xs:enumeration value="bolddoublequote"/>
              <xs:enumeration value="bolditalic"/>
              <xs:enumeration value="boldsinglequote"/>
              <xs:enumeration value="boldsmcaps"/>
              <xs:enumeration value="boldunderline"/>
              <xs:enumeration value="doublequote"/>
              <xs:enumeration value="italic"/>
              <xs:enumeration value="nonproport"/>
              <xs:enumeration value="singlequote"/>
              <xs:enumeration value="smcaps"/>
              <xs:enumeration value="sub"/>
              <xs:enumeration value="super"/>
              <xs:enumeration value="underline"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="expan" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="abbr" type="xs:token"/>
  </xs:complexType>
  <xs:complexType name="foreign" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="render">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="altrender"/>
          <xs:enumeration value="bold"/>
          <xs:enumeration value="bolddoublequote"/>
          <xs:enumeration value="bolditalic"/>
          <xs:enumeration value="boldsinglequote"/>
          <xs:enumeration value="boldsmcaps"/>
          <xs:enumeration value="boldunderline"/>
          <xs:enumeration value="doublequote"/>
          <xs:enumeration value="italic"/>
          <xs:enumeration value="nonproport"/>
          <xs:enumeration value="singlequote"/>
          <xs:enumeration value="smcaps"/>
          <xs:enumeration value="sub"/>
          <xs:enumeration value="super"/>
          <xs:enumeration value="underline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="lb"/>
  <xs:complexType name="num">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="encodinganalog" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="quote">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attributeGroup ref="am.common"/>
        <xs:attribute name="localtype" type="xs:token"/>
        <xs:attribute name="render">
          <xs:simpleType>
            <xs:restriction base="xs:token">
              <xs:enumeration value="altrender"/>
              <xs:enumeration value="bold"/>
              <xs:enumeration value="bolddoublequote"/>
              <xs:enumeration value="bolditalic"/>
              <xs:enumeration value="boldsinglequote"/>
              <xs:enumeration value="boldsmcaps"/>
              <xs:enumeration value="boldunderline"/>
              <xs:enumeration value="doublequote"/>
              <xs:enumeration value="italic"/>
              <xs:enumeration value="nonproport"/>
              <xs:enumeration value="singlequote"/>
              <xs:enumeration value="smcaps"/>
              <xs:enumeration value="sub"/>
              <xs:enumeration value="super"/>
              <xs:enumeration value="underline"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ptr">
    <xs:attributeGroup ref="am.common.empty"/>
    <xs:attributeGroup ref="am.internal.ptr"/>
    <xs:attribute name="entityref" type="xs:ENTITY"/>
  </xs:complexType>
  <xs:complexType name="ref" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="abbr" type="abbr"/>
      <xs:element name="expan" type="expan"/>
      <xs:element name="emph" type="emph"/>
      <xs:element name="foreign" type="foreign"/>
      <xs:element name="lb" type="lb"/>
      <xs:element name="ptr" type="ptr"/>
      <xs:element name="quote" type="quote"/>
      <xs:element name="num" type="num"/>
      <xs:element name="footnote" type="footnote"/>
      <xs:element name="date" type="date"/>
      <xs:group ref="m.access"/>
    </xs:choice>
    <xs:attributeGroup ref="am.common"/>
    <xs:attributeGroup ref="am.internal.ptr"/>
    <xs:attribute name="entityref" type="xs:ENTITY"/>
  </xs:complexType>
  <!-- DSC -->
  <xs:complexType name="dsc">
    <xs:sequence>
      <xs:sequence>
        <xs:element name="head" type="head" minOccurs="0"/>
        <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.blocks"/>
      </xs:sequence>
      <xs:element name="thead" type="thead" minOccurs="0"/>
      <xs:group minOccurs="0" ref="m.cOrC01"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="dsctype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="analyticover"/>
          <xs:enumeration value="combined"/>
          <xs:enumeration value="in-depth"/>
          <xs:enumeration value="otherdsctype"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="otherdsctype" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:complexType>
  <!-- M001: rimosso il tipo "c" -->
  <xs:complexType name="c01">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c02" type="c02" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c02">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c03" type="c03" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c03">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c04" type="c04" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c04">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c05" type="c05" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c05">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c06" type="c06" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c06">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c07" type="c07" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c07">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c08" type="c08" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c08">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c09" type="c09" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c09">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c10" type="c10" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c10">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c11" type="c11" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c11">
    <xs:complexContent>
      <xs:extension base="m.c.base">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="thead" type="thead" minOccurs="0"/>
          <xs:element name="c12" type="c12" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="c12">
    <xs:complexContent>
      <xs:extension base="m.c.base"/>
    </xs:complexContent>
  </xs:complexType>
  <!-- RELATIONS -->
  <xs:complexType name="relations">
    <xs:sequence>
      <xs:element name="relation" type="relation" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="base" type="xs:anyURI"/>
  </xs:complexType>
  <xs:complexType name="relation">
    <xs:sequence>
      <xs:element name="relationentry" type="relationentry" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="objectxmlwrap" type="objectxmlwrap" minOccurs="0"/>
      <xs:choice minOccurs="0">
        <xs:element name="datesingle" type="datesingle"/>
        <xs:element name="daterange" type="daterange"/>
        <xs:element name="dateset" type="dateset"/>
      </xs:choice>
      <xs:element name="geogname" type="geogname" minOccurs="0"/>
      <xs:element name="descriptivenote" type="descriptivenote" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="relationtype" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="cpfrelation"/>
          <xs:enumeration value="resourcerelation"/>
          <xs:enumeration value="functionrelation"/>
          <xs:enumeration value="otherrelationtype"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="otherrelationtype" type="xs:token"/>
    <xs:attribute name="lastdatetimeverified">
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:date">
              <xs:maxInclusive value="2099-12-31"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYear">
              <xs:maxInclusive value="2099"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYearMonth">
              <xs:maxInclusive value="2099-12"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:dateTime">
              <xs:maxInclusive value="2099-12-31T23:59:59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="am.simplelink"/>
  </xs:complexType>
  <xs:complexType name="relationentry" mixed="true">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
    <xs:attribute name="localtype" type="xs:token"/>
    <xs:attribute name="transliteration" type="xs:NMTOKEN"/>
  </xs:complexType>
  <xs:complexType name="objectxmlwrap">
    <xs:complexContent>
      <xs:extension base="e.anyname">
        <xs:attributeGroup ref="am.common"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="e.anyname">
    <xs:sequence>
      <xs:any namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  <!-- ELEMENT MODELS -->
  <xs:group name="m.blocks">
    <xs:choice>
      <xs:group ref="m.inter"/>
      <xs:element name="p" type="p"/>
    </xs:choice>
  </xs:group>
  <xs:group name="m.inter">
    <xs:choice>
      <xs:group ref="m.inter.noquote"/>
      <xs:element name="blockquote" type="blockquote"/>
    </xs:choice>
  </xs:group>
  <xs:group name="m.inter.noquote">
    <xs:choice>
      <xs:element name="chronlist" type="chronlist"/>
      <xs:element name="list" type="list"/>
      <xs:element name="table" type="table"/>
    </xs:choice>
  </xs:group>
  <xs:group name="m.cOrC01">
    <xs:choice>
      <!-- M001: utilizzate le tre versioni di "c" a seconda dei valori
                 di @level -->
      <xs:element name="c" maxOccurs="unbounded">
        <xs:alternative type="c.arch" test="@level = 'file'"/>
        <xs:alternative type="c.docu" test="@level = 'item'"/>
        <xs:alternative type="c.comp"/>
      </xs:element>
      <xs:element name="c01" type="c01" maxOccurs="unbounded"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="m.c.base">
    <xs:sequence>
      <xs:element name="head" type="head" minOccurs="0"/>
      <xs:element name="did" type="did"/>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.desc.base"/>
    </xs:sequence>
    <xs:attributeGroup ref="am.desc.c"/>
  </xs:complexType>
  <xs:group name="m.access">
    <xs:choice>
      <xs:element name="persname" type="persname"/>
      <xs:element name="corpname" type="corpname"/>
      <xs:element name="famname" type="famname"/>
      <xs:element name="geogname" type="geogname"/>
      <xs:element name="name" type="name"/>
      <xs:element name="occupation" type="occupation"/>
      <!--
      <xs:element name="subject" type="subject"/>
      -->
      <!-- M239: utilizzo di "subject.tema" quando il @localtype del
                 figlio "subject" e' pari a "Tematismo" -->
      <xs:element name="subject">
        <xs:alternative type="subject.tema" test="@localtype = 'Tematismo'"/>
        <xs:alternative type="subject"/>
      </xs:element>
      <xs:element name="genreform" type="genreform"/>
      <xs:element name="function" type="function"/>
      <xs:element name="title" type="title"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="m.datesingle">
    <xs:complexContent>
      <xs:extension base="m.mixed.basic">
        <xs:attribute name="standarddate" type="xs:token"/>
        <xs:attribute name="notbefore" type="xs:token"/>
        <xs:attribute name="notafter" type="xs:token"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="m.desc.base">
    <xs:choice>
      <xs:element name="accessrestrict" type="accessrestrict"/>
      <xs:element name="accruals" type="accruals"/>
      <xs:element name="acqinfo" type="acqinfo"/>
      <xs:element name="altformavail" type="altformavail"/>
      <xs:element name="appraisal" type="appraisal"/>
      <xs:element name="arrangement" type="arrangement"/>
      <xs:element name="bibliography" type="bibliography"/>
      <xs:element name="bioghist" type="bioghist"/>
      <xs:element name="controlaccess" type="controlaccess"/>
      <xs:element name="custodhist" type="custodhist"/>
      <xs:element name="fileplan" type="fileplan"/>
      <xs:element name="index" type="index"/>
      <xs:element name="legalstatus" type="legalstatus"/>
      <xs:element name="odd" type="odd"/>
      <xs:element name="originalsloc" type="originalsloc"/>
      <xs:element name="otherfindaid" type="otherfindaid"/>
      <xs:element name="phystech" type="phystech"/>
      <xs:element name="prefercite" type="prefercite"/>
      <xs:element name="processinfo" type="processinfo"/>
      <xs:element name="relatedmaterial" type="relatedmaterial"/>
      <xs:element name="relations" type="relations"/>
      <xs:element name="scopecontent" type="scopecontent"/>
      <xs:element name="separatedmaterial" type="separatedmaterial"/>
      <xs:element name="userestrict" type="userestrict"/>
    </xs:choice>
  </xs:group>
  <xs:group name="m.did">
    <xs:choice>
      <xs:element name="abstract" type="abstract"/>
      <xs:element name="container" type="container"/>
      <xs:element name="dao" type="dao"/>
      <xs:element name="daoset" type="daoset"/>
      <xs:element name="didnote" type="didnote"/>
      <xs:element name="langmaterial" type="langmaterial"/>
      <xs:element name="materialspec" type="materialspec"/>
      <xs:element name="origination" type="origination"/>
      <xs:element name="physdescset" type="physdescset"/>
      <xs:element name="physdesc" type="physdesc"/>
      <xs:element name="physdescstructured" type="physdescstructured"/>
      <xs:element name="physloc" type="physloc"/>
      <xs:element name="repository" type="repository"/>
      <xs:element name="unitdate" type="unitdate"/>
      <xs:element name="unitdatestructured" type="unitdatestructured"/>
      <xs:element name="unitid" type="unitid"/>
      <xs:element name="unittitle" type="unittitle"/>
    </xs:choice>
  </xs:group>
  <xs:group name="m.refs">
    <xs:choice>
      <xs:element name="ptr" type="ptr"/>
      <xs:element name="ref" type="ref"/>
    </xs:choice>
  </xs:group>
  <!-- MIXED CONTENT MODELS -->
  <xs:group name="m.mixed.basic.elements">
    <xs:choice>
      <xs:element name="abbr" type="abbr"/>
      <xs:element name="emph" type="emph"/>
      <xs:element name="expan" type="expan"/>
      <xs:element name="foreign" type="foreign"/>
      <xs:element name="lb" type="lb"/>
      <xs:element name="ptr" type="ptr"/>
      <xs:element name="ref" type="ref"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="m.mixed.basic" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.mixed.basic.elements"/>
  </xs:complexType>
  <xs:group name="m.mixed.basic.date.elements">
    <xs:choice>
      <xs:element name="abbr" type="abbr"/>
      <xs:element name="date" type="date"/>
      <xs:element name="emph" type="emph"/>
      <xs:element name="expan" type="expan"/>
      <xs:element name="foreign" type="foreign"/>
      <xs:element name="lb" type="lb"/>
      <xs:element name="ptr" type="ptr"/>
      <xs:element name="ref" type="ref"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="m.mixed.basic.date" mixed="true">
    <xs:group minOccurs="0" maxOccurs="unbounded" ref="m.mixed.basic.date.elements"/>
  </xs:complexType>
  <xs:group name="m.mixed.basic.plus.elements">
    <xs:choice>
      <xs:group ref="m.mixed.basic.elements"/>
      <xs:element name="date" type="date"/>
      <xs:element name="footnote" type="footnote"/>
      <xs:element name="num" type="num"/>
      <xs:element name="quote" type="quote"/>
    </xs:choice>
  </xs:group>
  <xs:complexType name="m.mixed.basic.plus.access" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="m.mixed.basic.elements"/>
      <xs:group ref="m.access"/>
      <xs:element name="date" type="date"/>
      <xs:element name="footnote" type="footnote"/>
      <xs:element name="num" type="num"/>
      <xs:element name="quote" type="quote"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="m.para.content" mixed="true">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="m.mixed.basic.plus.elements"/>
      <xs:group ref="m.access"/>
      <xs:element name="list" type="list"/>
    </xs:choice>
  </xs:complexType>
  <!-- ATTRIBUTE MODELS -->
  <xs:attributeGroup name="am.internal.ptr">
    <xs:attribute name="target" type="xs:IDREF"/>
    <xs:attribute name="xpointer" type="xs:token"/>
    <xs:attributeGroup ref="am.simplelink"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.simplelink">
    <xs:attribute name="href" type="xs:token"/>
    <xs:attribute name="linkrole" type="xs:anyURI"/>
    <xs:attribute name="arcrole" type="xs:anyURI"/>
    <xs:attribute name="linktitle" type="xs:token"/>
    <xs:attribute name="show">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="new"/>
          <xs:enumeration value="replace"/>
          <xs:enumeration value="embed"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="actuate">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="onload"/>
          <xs:enumeration value="onrequest"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.common.empty">
    <xs:attribute name="id" type="xs:ID"/>
    <xs:attribute name="altrender" type="xs:token"/>
    <xs:attribute name="audience">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="external"/>
          <xs:enumeration value="internal"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.common">
    <xs:attributeGroup ref="am.common.empty"/>
    <xs:attribute name="lang" type="xs:NMTOKEN"/>
    <xs:attribute name="script" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.desc.base">
    <xs:attribute name="otherlevel" type="xs:token"/>
    <xs:attribute name="encodinganalog" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.desc.c">
    <xs:attributeGroup ref="am.common"/>
    <xs:attribute name="base" type="xs:anyURI"/>
    <xs:attribute name="level">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="class"/>
          <xs:enumeration value="collection"/>
          <xs:enumeration value="file"/>
          <xs:enumeration value="fonds"/>
          <xs:enumeration value="item"/>
          <xs:enumeration value="otherlevel"/>
          <xs:enumeration value="recordgrp"/>
          <xs:enumeration value="series"/>
          <xs:enumeration value="subfonds"/>
          <xs:enumeration value="subgrp"/>
          <xs:enumeration value="subseries"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="am.desc.base"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.access">
    <xs:attributeGroup ref="am.access.no.normal"/>
    <xs:attribute name="normal" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.access.no.normal">
    <xs:attribute name="source" type="xs:token"/>
    <xs:attribute name="rules" type="xs:NMTOKEN"/>
    <xs:attribute name="identifier" type="xs:token"/>
  </xs:attributeGroup>
  <!-- ATTRIBUTE DEFINITIONS -->
  <!-- xlink-modelled attributes -->
  <xs:attributeGroup name="a.link.actuate">
    <xs:attribute name="actuate" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="onload"/>
          <xs:enumeration value="onrequest"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.arcrole">
    <xs:attribute name="arcrole" use="required" type="xs:anyURI"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.href">
    <xs:attribute name="href" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.role">
    <xs:attribute name="linkrole" use="required" type="xs:anyURI"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.show">
    <xs:attribute name="show" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="new"/>
          <xs:enumeration value="replace"/>
          <xs:enumeration value="embed"/>
          <xs:enumeration value="other"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.title">
    <xs:attribute name="linktitle" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <!-- other linking-related attributes -->
  <xs:attributeGroup name="a.base">
    <xs:attribute name="base" use="required" type="xs:anyURI"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.identifier">
    <xs:attribute name="identifier" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.parent">
    <xs:attribute name="parent" use="required" type="xs:IDREFS"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.relator">
    <xs:attribute name="relator" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.link.xpointer">
    <xs:attribute name="xpointer" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.entityref">
    <xs:attribute name="entityref" use="required" type="xs:ENTITY"/>
  </xs:attributeGroup>
  <!-- display attributes -->
  <xs:attributeGroup name="a.align">
    <xs:attribute name="align" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="left"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="center"/>
          <xs:enumeration value="justify"/>
          <xs:enumeration value="char"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.valign">
    <xs:attribute name="valign" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="top"/>
          <xs:enumeration value="middle"/>
          <xs:enumeration value="bottom"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.render">
    <xs:attribute name="render" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="altrender"/>
          <xs:enumeration value="bold"/>
          <xs:enumeration value="bolddoublequote"/>
          <xs:enumeration value="bolditalic"/>
          <xs:enumeration value="boldsinglequote"/>
          <xs:enumeration value="boldsmcaps"/>
          <xs:enumeration value="boldunderline"/>
          <xs:enumeration value="doublequote"/>
          <xs:enumeration value="italic"/>
          <xs:enumeration value="nonproport"/>
          <xs:enumeration value="singlequote"/>
          <xs:enumeration value="smcaps"/>
          <xs:enumeration value="sub"/>
          <xs:enumeration value="super"/>
          <xs:enumeration value="underline"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.label">
    <xs:attribute name="label" use="required" type="xs:string"/>
  </xs:attributeGroup>
  <!-- date attributes -->
  <xs:attributeGroup name="am.dates.calendar">
    <xs:attribute name="calendar" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.dates.era">
    <xs:attribute name="era" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.date.normal">
    <xs:attribute name="normal" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.lastdatetimeverified">
    <xs:attribute name="lastdatetimeverified" use="required">
      <xs:simpleType>
        <xs:union>
          <xs:simpleType>
            <xs:restriction base="xs:date">
              <xs:maxInclusive value="2099-12-31"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYear">
              <xs:maxInclusive value="2099"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:gYearMonth">
              <xs:maxInclusive value="2099-12"/>
            </xs:restriction>
          </xs:simpleType>
          <xs:simpleType>
            <xs:restriction base="xs:dateTime">
              <xs:maxInclusive value="2099-12-31T23:59:59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:union>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.datechar">
    <xs:attribute name="datechar" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.certainty">
    <xs:attribute name="certainty" use="required" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.normal">
    <xs:attribute name="normal" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <!-- typing attributes -->
  <xs:attributeGroup name="a.encodinganalog">
    <xs:attribute name="encodinganalog" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.level">
    <xs:attribute name="level" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="class"/>
          <xs:enumeration value="collection"/>
          <xs:enumeration value="file"/>
          <xs:enumeration value="fonds"/>
          <xs:enumeration value="item"/>
          <xs:enumeration value="otherlevel"/>
          <xs:enumeration value="recordgrp"/>
          <xs:enumeration value="series"/>
          <xs:enumeration value="subfonds"/>
          <xs:enumeration value="subgrp"/>
          <xs:enumeration value="subseries"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.localtype">
    <xs:attribute name="localtype" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.relatedencoding">
    <xs:attribute name="relatedencoding" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.unitdatetype">
    <xs:attribute name="unitdatetype">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="bulk"/>
          <xs:enumeration value="inclusive"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <!-- table attributes -->
  <xs:attributeGroup name="a.char">
    <xs:attribute name="char" use="required" type="xs:token"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.charoff">
    <xs:attribute name="charoff" use="required" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.colname">
    <xs:attribute name="colname" use="required" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.colsep">
    <xs:attribute name="colsep" use="required" type="av.boolean"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.rowsep">
    <xs:attribute name="rowsep" use="required" type="av.boolean"/>
  </xs:attributeGroup>
  <!-- other attributes -->
  <xs:attributeGroup name="a.coverage">
    <xs:attribute name="coverage" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:token">
          <xs:enumeration value="whole"/>
          <xs:enumeration value="part"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="am.countrycode">
    <xs:attribute name="countrycode" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="a.transliteration">
    <xs:attribute name="transliteration" use="required" type="xs:NMTOKEN"/>
  </xs:attributeGroup>
  <!-- ATTRIBUTE VALUE LISTS -->
  <xs:simpleType name="av.boolean">
    <xs:restriction base="xs:token">
      <xs:enumeration value="true"/>
      <xs:enumeration value="false"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
